#### 62. C++中将临时变量作为返回值时的处理过程

首先注意，临时变量是不能做使用引用返回的，C++中最好不要这样做。

首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，**当函数退出时，临时变量出栈，即临时变量已经被销毁**，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了。

C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。

由此可见，函数调用结束后，返回值被临时存储到**==寄存器==**中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。



#### 63. 如何获得结构成员相对于结构开头的字节偏移量

注意，这里涉及到内存对齐的知识，一般会按照**最大成员变量进行内存对齐**，也跟结构体中定义的位置有关。

使用<stddef.h>头文件中的，offsetof宏。

举个例子：

```cpp
#include <iostream>
#include <stddef.h>
using namespace std;

struct  S
{
	int x;
	char y;
	int z;
	double a;
};
int main()
{
	cout << offsetof(S, x) << endl; // 0
	cout << offsetof(S, y) << endl; // 4
	cout << offsetof(S, z) << endl; // 8
	cout << offsetof(S, a) << endl; // 16
	return 0;
}
```

在Visual Studio 2022 + Win11 下的输出情况如上

具体的分析如下，首先成员中最长的就是double，为8个字节，所以内存对齐都要按照8个字节来对齐，具体的示意图如下：

![1690858949069](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690858949069.png)



#### 64. 静态类型和动态类型，静态绑定和动态绑定的介绍（多态中的体现）

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

简单的说：==**动态类型是可以发生变化的；并且动态类型的概念是针对指针和引用这两个东西而引出来的**==。

```cpp
class Base
{

};
class Derived:public Base
{

};
class SubDerived:public Derived
{

};
int main()
{


Base* pb = new Derived; //pb的静态类型为Base*，我们不用运行就知道了，编译时候就能够确定下来；
						//pb的动态类型为 Derived*，这个只有在运行阶段才可以确定下来，
						//即程序运行到这句代码，才可以直到pb的动态类型为 Derived*
						
Derived der; //派生类对象，派生类的对象der的静态类型为derived,动态类型：无；
Base& pc = der; //pc的静态类型为 base,动态类型为 derived;

pb = new SubDerived; //pb的静态类型为 Base,动态类型为：SubDerived
					//重要的理解：pb动态类型从原来的Derived,变到现在的SubDerived
					//也说明了程序运行到这里，才可以确定pb的动态类型是什么，并且它是可以变化的

Base* pd = & der; //pd静态类型为 Base* ,动态类型为 Derived;
SubDerived subDer;
pd = &subDer; //pd静态类型为：Base*，动态类型从Derived变成了SubDerived
Base& pe = der; //pd静态类型为Base动态类型为 Derived;
//___________________________________________________________________________
//上面都是动态类型和静态类型不一致的情况，那么什么时候动态类型和静态类型会是一致的呢？
//举几个例子如下情况：
Base* p1 = new Base; //p1静态类型为Base*,动态类型为：Base*，它们是一致的；
Base base1; //base1的静态类型为：Base,base1对象没有动态类型的概念，因为他不是指针或者引用类型
p1 = &base;//p1静态类型为Base*,动态类型为：Base*，它们是一致的；
Base base2; //base2的静态类型为：Base;没有动态类型的概念
p1 = &base2; //p1的静态类型为Base*,动态类型为：Base*，没有发生改变，虽然它们指向的是不同的对象

	return 0;
}

```

下面再介绍静态绑定，动态绑定：

1. 静态绑定：有人也叫为早绑定，早绑定什么呢？对象所调用的函数的地址，这个阶段是程序编译阶段就确定的了；
2. 动态绑定：有人也叫晚绑定，也就是编译阶段时候不能确定对象调用函数的地址，需要程序运行到调用函数的阶段才可以确定；**绑定这个词，它是相对于函数来说的，把对象（包括指针或者引用）和函数绑定在一起**

```cpp
#include<iostream>
using namespace std;

class Base
{
public:
	void fun()
	{
		cout <<" Base::fun() "<< endl;
	}
};
class Derived :public Base
{
public:
	void fun()
	{
		cout <<" Derived::fun() "<< endl;
	}
};
class SubDerived :public Derived
{

public:
	void fun()
	{
		cout << "SubDerived::fun()" << endl;
	}
};
int main()
{
	Base* b1 = new Base;
	b1->fun();
	Derived* d1 = new Derived;
	d1->fun();
	SubDerived* s1 = new SubDerived;
	s1->fun();
	return 0;
}
```

b1 的静态类型为：Base*,动态类型为：Base*; b1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型一致，可是这个动态类型却不影响它的静态绑定的事实；
d1 的静态类型为：Derived*,动态类型为：Derived* ;d1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型一致，可是这个动态类型却不影响它的静态绑定的事实；
s1的静态类型为：SubDerived*,动态类型为：SubDerived*; s1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型一致，可是这个动态类型却不影响它的静态绑定的事实；

![在这里插入图片描述](https://img-blog.csdnimg.cn/9882a188877d41b2b1be446674133335.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZGL5ZaD5ZCW,size_20,color_FFFFFF,t_70,g_se,x_16)

下面我们更改一下，**父类指针指向子类对象**

```cpp
int main()
{
	Base* b1 = new Derived;
	b1->fun(); 
	Derived* d1 = new SubDerived;
	d1->fun();
	return 0;
}

```

**结果也是可以理解的：虽然说是父类指针指向了子类对象，可是也是调用子类对象中父类的成员**，这就是c++中的隐藏，因为父类的成员不是虚函数，所以会出现这样的情况。

b1 的静态类型为：Base*,动态类型为：Derived*; b1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型不一致，可是这个动态类型却不影响它的静态绑定的事实；
d1 的静态类型为：Derived*,动态类型为：SubDerived*; d1->fun( )这个就是**静态绑定**，虽然我们的d1的动态类型和静态类型不一致，可是这个动态类型却不影响它的静态绑定的事实；

**下面我们继续改，此时我们给类加了虚函数：**

```cpp
#include<iostream>
using namespace std;
class Base
{
public:
	void fun()
	{
		cout <<"Base::fun() "<< endl;
	}
	virtual void virFun()
	{
		cout << "Base::virfun() " << endl;
	}
};
class Derived :public Base
{
public:
	void fun()
	{
		cout <<"Derived::fun() "<< endl;
	}
	virtual void virFun()
	{
		cout << "Derived::virfun() " << endl;
	}
};
class SubDerived :public Derived
{

public:
	void fun()
	{
		cout << "SubDerived::fun()" << endl;
	}
	virtual void virFun()
	{
		cout << "SubDerived::virfun() " << endl;
	}
};
void Test3()
{
	Base* b1 = new Derived;
	b1->virFun();
	Base* b2 = new SubDerived;
	b2->virFun();
	Base* b3 = b2;
	b3->virFun();
	Derived* d1 = new SubDerived;
	d1->virFun();
}
int main()
{
	Test3();
	return 0;
}
```

运行结果：

![1690876825165](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690876825165.png)

**有了虚函数，并且子类重写父类的虚函数，且父类的指针指向子类对象，那么就会发生变化，此时就发生了==多态==的行为：==用父类的指针可以调用子类中的成员了==**。

==总的一句话说：只有虚函数使用的绑定才是动态绑定。==

但不代表说虚函数的绑定都是动态绑定，前提还得是**指针或引用**类型绑定虚函数才可以；

其他的函数绑定方式都是静态绑定！不管你的指针类型引用类型或对象来说是静态类型还是动态类型，只要它们不联系上虚函数都是静态绑定！

下面的例子：

```cpp
int main() {
    Base b;
    b.virFun();
    
    Base* b1 = new Base;
    b1->virFun();
    return 0;
}
```

b对象是普通的对象，不管怎么说肯定都是静态绑定。

对于b1而言，其静态类型为Base*， 动态类型也是 Base *，虽然都是一样的，但是由于他是指针类型的，这个也是**==动态绑定==**！不要理解成静态绑定了。

**建议：**

绝对不要**重新定义继承而来的非虚(non-virtual)函数**（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，**没有多态**，也这将给程序留下不可预知的**隐患和莫名其妙的BUG**。

参考：[(44条消息) 对C++中的静态类型，动态类型，静态绑定，动态绑定的理解_c++静态类型动态类型_呋喃吖的博客-CSDN博客](https://blog.csdn.net/m0_46606290/article/details/121538603)

#### **65. 全局变量和局部变量有什么区别？**

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量分配在**==静态存储区域==**，在程序的各个部分都可以用到；局部变量分配在**==堆栈区==**，只能在局部使用。



#### 66. C/C++程序的5种内存存储区

C/C++主要有以下五种内存存储区：

- **全局/静态存储区域**

存**全局变量，静态变量**。程序编译时内存已分配好，并存在于程序整个运行期间，程序结束后由系统统一释放。

- **栈区**

存放**函数的参数值，局部变量**，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。

- **堆（动态内存分配）**：

通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。

- **字符/文字常量区**

存放**常量字符串**，程序结束时由系统释放。

- **程序代码区**

存放函数体的二进制代码



#### 67. 指针加减计算要注意什么？

指针加减本质是对其所指**地址的移动**，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。

遇到指针的计算，**需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果**。int arr[10];  arr+1就代表指向下一个int型变量，实际跨越了4个字节。



#### 68. 怎样判断两个浮点数是否相等？

由于浮点数存在精度问题，所以对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！对于两个浮点数比较只能通过相减并与**预先设定的精度比较**，记得要取绝对值！

```cpp
const double EPS = 0.0000001;
abs(a - b) < EPS
```



#### 69. 类如何实现只能静态分配和只能动态分配

C++中建立类的对象有两种方式：
（1）静态建立，例如 A a;
静态建立一个类对象，就是由编译器为对象在栈空间中分配内存。使用这种方法，是**直接调用类的构造函数**。
（2）动态建立，例如 A* p = new A();
动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步：第一步执行**operator new( )**函数，在**堆空间**中搜索一块内存并进行分配；第二步调用类的构造函数构造对象。这种方法是**间接调用类的构造函数**。



**只能静态分配：**(只能在栈上分配)

只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有，实现如下：

```cpp
class A  
{  
private:  
     void* operator new(size_t t){}          //注意函数的第一个参数和返回值都是固定的  
     void operator delete(void* ptr){}       //重载了new就需要重载delete  
public:  
     A(){}  
     ~A(){}  
};  
```

**只能动态分配：**（只能在堆上分配）

当我们想**禁止在栈中产生对象**时，如何来实现呢？

将构造函数设为private行吗？no！这样**对象虽然不能在栈中产生，但同样也不能在堆中产生**了。

将析构函数设为private行吗？bad！这样虽然限制了栈对象，但同时也**限制了继承**。

将析构函数设为protected行吗？yes！

把类的构造函数和析构函数设为protected属性。**类对象不能访问，但是派生类可以继承，也可以访问**。



#### 70. 如果想将某个类用作基类，为什么该类必须定义而非声明？

派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。

所以必须定义而非声明。(至少父亲是已经存在的，才可能有孩子)



#### 71.  知道C++中的组合吗？它与继承相比有什么优缺点吗？

**1. 继承**

继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。

继承的缺点有以下几点：

- 父类的内部细节对子类是可见的。
- 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
- 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

**2. 结合**

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。

组合的优点：

- 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。


- 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
- 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义



#### 72. 函数指针

1. **什么是函数指针？**

   如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。

2. **函数指针的声明方法**

   ```cpp
   int (*pf)(const int&, const int&);
   ```

    上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&参数的函数。注意*pf两边的括号是必须的。

3.  **为什么有函数指针**

   函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。

4. **一个函数名就是一个指针，它指向函数的代码**

   一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。

5. **两种方法赋值**

   指针名 = 函数名； 指针名 = &函数名



#### 73. 结构体变量比较是否相等

1. **重载了 “==” 操作符**

```cpp
struct foo {

  int a;
  int b;

  bool operator==(const foo& rhs) *//* *操作运算符重载*

  {
    return( a == rhs.a) && (b == rhs.b);
  }
};
```

2. 元素的话，一个个比；
3. 指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真。



#### 74. 你知道printf函数的实现原理是什么吗？

高地址像低地址生长？低地址向高地址生长？



#### 75. cout和printf有什么区别？



#### 101. 几个this指针的易混问题

this指针只能在一个类的非静态，非全局成员函数中调用，它表示当前对象的地址，下面三种模式是等价的：

```cpp
void Date::setMonth( int mn ) {
    month = mn; // 这三句是等价的
    this->month = mn;
    (*this).month = mn;
}
```

1. **this指针是什么时候创建的?**

   this在成员函数的开始执行前构造的，在成员的执行结束后清除。

2. **this指针存放在何处? 堆,栈,全局变量,还是其他?**

   this指针会因编译器不同，而放置的位置不同。可能是栈，也可能是寄存器，甚至全局变量。

3. **this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？**

   this是通过函数参数的首参数来传递的。这个在之前也提到过了函数参数传递的等价形式，this在第一个参数。

4. **this指针是如何访问类中的变量的？**

   this指针是通过成员函数来访问类中的变量的，具体而言，执行成员函数时，编译器会理解将改成员函数的首参数理解为指向改对象的指针，即this指针，进入函数之后，便可以直接使用this指针访问当前实例对象的变量。

5. **我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？**

   **this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。并且来说，就算在成员函数里面，this本来就是一个指针，如果要获得地址直接 `(long) this` 即可。

   注意，this一般而言是一个**右值**，所以`&this`肯定是不合法的。

6. **每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？**

   普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。



#### **c++常见的锁**？

#### 构造函数和析构函数调用虚函数？

#### gdb调试段错误



#### 102. 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

首先来说，肯定**可以在成员函数中调用delete this**。

通过代码来看看这个问题：

```cpp
class Test
{
public:
    Test(int _x);
    void foo();
    void show();
    void show(int);
private:
    int x;
};

Test::Test(int _x) :x(_x)
{
}

void Test::show()
{
    cout << "x = " << x << endl;
}

void Test::show(int)
{
    cout << "this is show int" << endl;
}

void Test::foo()
{
    delete this;
}

int main()
{
    Test* t1 = new Test(5);
    cout << "before" << endl;
    t1->show();
    t1->foo();
    cout << "after" << endl;
    t1->show();
    t1->show(1);
    system("pause");
    return 0;
}
```

运行结果如下所示：

![1691399224765](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691399224765.png)

可以看到，在foo函数中delete了this，确实起到了作用（因为x的内存已经被释放了，x已经随便给了一个值），但是`show(int)`函数还是可以执行。

这说明了：并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法**不涉及这个对象的数据成员和虚函数**。

可以按照下面的解释：

在类对象的内存空间中，只有**数据成员和虚函数表指针**，并不包含代码内容（代码区），而普通的成员函数，包括全局函数和静态函数，都是存放在代码区的。所以使用delete释放了类对象的内存空间，只释放了数据成员和虚函数表指针的内存，对于代码区中的函数而言，不涉及到this指针的内容，所以是不受影响的，仍然可以调用。

追问：**delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？**

delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，**可能是缓冲或者其他什么原因**，导致这段内存空间暂时并没有被系统收回，此时这段内存是可以访问的。



#### 102. 在析构函数中调用delete this会怎么样？

```cpp
#include <iostream>
using namespace std;
 
class A
{
public:
	A()
	{
		cout<<"A()"<<endl;
	}
	~A()
	{
		cout<<"~A()"<<endl;
		delete this;
	}
};
 
int main()
{
	A a;
	return 0;
}
```

析构函数中调用delete this：上面这段程序的`delete this`会先调~ A()，然后再释放空间，这样每次调用delete都会调用~A()，而 ~A()又要调用delete，他们相互调用，就会形成死循环，造成堆栈溢出。



#### 103. 你知道空类的大小是多少吗？

1. C++空类的大小不为0，不同编译器设置不一样，vs设置为1，**因为空类可以实例化，实例化必然在内存中占有一个位置，因此，编译器为其优化为一个字节大小**。
2. C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
3. 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
4. C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。



#### 104. 指针占几个字节？

32位系统占4个字节；64位系统占8个字节。



#### 105. C++类的大小怎么决定？

先总述：

1. 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
2. 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
3. 虚函数的话，会在类对象插入vptr指针，加上指针大小；
4. 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。

- **类的大小与什么有关系？**

  与类大小**==有关==**的因素：普通成员变量（非静态和全局成员变量），虚函数，继承（单一继承，多重继承，重复继承，虚拟继承）包括**s**。

  与类大小**==无关==**的因素：静态成员变量，静态成员函数及普通成员函数。

- **空类**

  空类的大小编译器优化为1，但是如果某一个类继承空类，那么那个空类的大小就会被优化。

  ```cpp
  class A {
  
  };
  
  class B : public A {
  public:
  	int m_a;
  };
  
  int main()
  {
  	A a;
  	cout << sizeof(a) << endl;
  
  	B b;
  	cout << sizeof(b) << endl;
  
  	system("pause");
  	return 0;
  }
  
  // 1
  // 4
  ```

- **内存对齐问题**

- **含虚函数的单一继承**

  ```cpp
  class Base
  {
  private:
      char a;
  public:
      virtual void f();
      virtual void g();
  };
  class Derived:public Base
  {
  private:
      int b;
  public:
      void f();
  };
  class Derived1:public Base
  {
  private:
      double b;
  public:
      void g();
      virtual void h();
  };
  ```

  基类Base中含有一个char型成员变量，以及两个虚函数，此时Base类的内存布局如下：

  ![img](https://img-blog.csdn.net/20180503185905354)

  内存布局的最一开始是vfptr（virtual function ptr）即虚函数表指针（只要含虚函数，一定有虚函数表指针，而且该指针一定位于类内存模型最前端），接下来是Base类的成员变量，按照在类里的声明顺序排列，当然啦，还是要像上面一样注意内存对齐原则！

  继承类Derived继承了基类，重写了Base中的虚函数f()，还添加了自己的成员变量，即int型的b，这时，Derived的类内存模型如下：

  ![img](https://img-blog.csdn.net/20180503190906435)

  此种情况下，最一开始的还是虚函数表指针，只不过，在Derived类中被重写的虚函数f()在对应的虚函数表项的Base::f()已经被替换为Derived::f()，接下来是基类的成员变量char a，紧接着是继承类的成员变量int b，按照其基类变量声明顺序与继承类变量声明顺序进行排列，并注意内存对齐问题。

  继承类Derived1继承了基类，重写了Base中的虚函数g()，还添加了自己的成员变量（即double型的b）与自己的虚函数（virtual h() ），这时，Derived1的类内存模型如下：

  ![img](https://img-blog.csdn.net/20180503211646994)

  此种情况下，Derived1类一开始仍然是虚函数表指针，只是在Derived1类中被重写的虚函数g()在对应的虚函数表项的Base::g()已经被替换为Derived1::g()，新添加的虚函数virtual h()位于虚函数表项的后面，紧跟着基类中最后声明的虚函数表项后，接下来仍然是基类的成员变量，紧接着是继承类的成员变量。

- **含虚函数的多重继承**

  ```cpp
  class Base1
  {
  private:
      char a;
  public:
      virtual void f();
      virtual void g1();
  };
  class Base2
  {
  private:
      int b;
  public:
      virtual void f();
      virtual void g2();
  };
  class Base3
  {
  private:
      double c;
  public:
      virtual void f();
      virtual void g3();
  };
  class Derived:public Base1, public Base2, public Base3
  {
  private:
      double d;
  public:
      void f();
      virtual void derived_func();
  }
  ```

  首先继承类多重继承了三个基类，此外继承类重写了三个基类中都有的虚函数virtual f()，还添加了自己特有的虚函数derived_func()，那么，新的继承类内存布局究竟是什么样子的呢？请看下图！先来看3个基类的内存布局：

  ![img](https://img-blog.csdn.net/20180503213023625)

  

  紧接着是继承类Derived的内存布局：

  ![img](https://img-blog.csdn.net/20180503214050458)

  首先，Derived类自己的虚函数表指针与其声明继承顺序的第一个基类Base1的虚函数表指针合并，此外，若Derived类重写了基类中同名的虚函数，则在三个虚函数表的对应项都应该予以修改，Derived中新添加的虚函数位于第一个虚函数表项后面，Derived中新添加的成员变量位于类的最后面，按其声明顺序与内存对齐原则进行排列。

- **菱形继承的问题及解决方案：虚拟继承**

  （1）不同环境下虚拟继承对类大小的影响
  
  在vs环境下，采用虚拟继承的继承类会有自己的虚函数表指针（**==假如基类有虚函数，并且继承类添加了自己新的虚函数==**）
  
  在gcc环境下及mac下使用clion，采用虚拟继承的继承类没有自己的虚函数表指针（假如基类有虚函数，无论添加自己新的虚函数与否），而是共用父类的虚函数表指针
  
  （2）虚拟继承会给继承类添加一个虚基类指针（virtual base ptr 简称vbptr），其位于类虚函数指针后面，成员变量前面，若基类没有虚函数，则vbptr其位于继承类的最前端。
  
  **虚继承的定义，为什么需要虚拟继承？**
  
  虚极继承主要是为了解决**菱形继承下公共基类的多份拷贝问题：**会造成同名成员的歧义
  
  ![img](https://pic3.zhimg.com/80/v2-37a3fde641d2e10e659d01f8041eb1b6_720w.webp)
  
  ```cpp
  //间接基类A
  class A{
  protected:
      int m_a;
  };
  
  //直接基类B
  class B: public A{
  protected:
      int m_b;
  };
  
  //直接基类C
  class C: public A{
  protected:
      int m_c;
  };
  
  //派生类D
  class D: public B, public C{
  public:
      void seta(int a){ m_a = a; }  //命名冲突
      void setb(int b){ m_b = b; }  //正确
      void setc(int c){ m_c = c; }  //正确
      void setd(int d){ m_d = d; }  //正确
  private:
      int m_d;
  };
  
  int main(){
      D d;
      return 0;
  }
  ```
  
  这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。
  
  为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：
  
  ```cpp
  void seta(int a){ B::m_a = a; }
  ```
  
  这样表示使用 B 类的 m_a。当然也可以使用 C 类的：
  
  ```cpp
  void seta(int a){ C::m_a = a; }
  ```
  
  如果将上述例子改为虚继承：
  
  ```cpp
  class B: virtual public A
  class C: virtual public A
  ```
  
  就可以设置m_a了，此时A就是B和C的虚基类。虽然感觉像是共享关系，但是还是各论各的，D中的m_a改了，A，B，C中的都不会改。



