[ (1 封私信 / 79 条消息) 计算机网络面试会问哪些问题？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/515249396)

[计算机网络面试题（含解答）2022版 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/471948799)

[面试汇总(三)：计算机网络常见面试总结(一) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/237948931)

[字节跳动最爱考的前端面试题：计算机网络基础 - 掘金 (juejin.cn)](https://juejin.cn/post/6939691851746279437)

总结以上几个人的计算机网络知识，都是分层讲解，我们也这样学习。

### 基础

#### **1. 说下计算机网络体系结构**

计算机网络体系结构，一般有三种：OSI 七层模型、TCP/IP 四层模型、五层结构（原理学习）。

![img](https://picx.zhimg.com/80/v2-1340bdaa07d3c9681a6cc095002179bd_720w.webp?source=1940ef5c)

简单说，OSI是一个理论上的网络通信模型，TCP/IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。



#### **2. OSI七层模型各自的功能是什么？**

**物理层**：底层数据传输，如网线等；代表协议有 IEEE802.3(以太网), IEEE802.11(WIFI)等

**数据链路层**：定义数据的基本格式；如网卡MAC地址；交换机；代表协议有MAC, VLAN, PPP等

**网络层**：定义IP地址，定义路由功能；如不同设备的数据转发；代表协议有IP，ARP, ICMP,；

**传输层**：端到端的传输数据的基本功能，如TCP，UDP；

**会话层**：控制应用程序的之间的通信；主要协议有RPC, SQL, NFS等；

**表示层**：数据格式标识，基本压缩加密；主要包括协议有，JPEG,ASCII;

**应用层**：各种应用软件；主要协议有FTP，HTTP，DNS， SMTP；

在物理层，数据被称为**比特流**，在数据链路层，数据被称为**帧**；在传输层，数据被称为**段**；网络层，数据被称为**包**。



#### 3. **说一下每一层对应的网络协议有哪些？**

一张表格总结常见网络协议：

![img](https://picx.zhimg.com/80/v2-870542e52d8044ecac43f802ad246ddc_720w.webp?source=1940ef5c)

#### 4. 那么数据在各层之间是怎么传输的呢？

对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。

- 发送方的应用进程向接收方的应用进程传送数据
- AP先将数据交给本主机的应用层，应用层加上本层的控制信息H5就变成了下一层的数据单元
- 传输层收到这个数据单元后，加上本层的控制信息H4，再交给网络层，成为网络层的数据单元
- 到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）
- 最后的物理层，进行比特流的传输

### 应用层

#### 5. 从浏览器地址栏输入 url 到显示主页的过程？

这道题，大概的过程比较简单，但是有很多点可以细挖：DNS解析、TCP三次握手、HTTP报文格式、TCP四次挥手等等。

1. DNS 解析：将域名解析成对应的 IP 地址；
2. TCP连接：与服务器通过三次握手，建立 TCP 连接；
3. 向服务器发送 HTTP 请求；
4. 服务器处理请求，返回HTTP响应;
5. 浏览器解析并渲染页面;
6. 断开连接：TCP 四次挥手，连接结束。

我们以输入[http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com) 为例：![img](https://pica.zhimg.com/80/v2-16f973a72a16ab80f8fbb63cf2bd1589_720w.webp?source=1940ef5c)

各个过程都使用了哪些协议？

![img](https://pica.zhimg.com/80/v2-09d4f7f1e7f459ac485c4eb2c5cb2cef_720w.webp?source=1940ef5c)

浏览器会解析URL地址，同时用**DNS**（应用层）将其转换为IP地址，**DNS服务器是基于UDP**（传输层）。

得到IP地址后，浏览器就要与服务器建立一个**HTTP**（应用层）连接。HTTP生成一个GET请求报文，并利用**TCP**（传输层）传输。TCP数据包然后会发送给**IP**层（网络层），IP层通过路由选择协议，如**OSPF**（网络接口层）和交换机等找到目的主机，匹配主机的MAC地址（数据链路层）。



下面就是深挖的过程

#### 6. **说说 DNS 的解析过程？**

DNS，英文全称是 **domain name system**，域名解析系统，它的作用也很明确，就是域名和 IP 相互映射。

DNS 的解析过程如下图：![img](https://pic1.zhimg.com/80/v2-148854d1363a0e9caff5dac546aacd91_720w.webp?source=1940ef5c)

假设你要查询 **http://www.baidu.com** 的 IP 地址:

1. 首先会查找浏览器的缓存，看看是否能找到baidu.com对应的IP地址，找到就直接返回；否则进行下一步。
2. 将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步;

![img](https://picx.zhimg.com/80/v2-045d8649ed9fc36fb86cd23c4a8baa45_720w.webp?source=1940ef5c)

3. 本地DNS服务器向根域名服务器发送请求，根域名服务器返回负责com 的顶级域名服务器的IP地址的列表。
4. 本地DNS服务器再向其中一个负责com的顶级域名服务器发送一个请求，返回负责baidu.com的权限域名服务器的IP地址列表。
5. 本地DNS服务器再向其中一个权限域名服务器发送一个请求，返回baidu.com所对应的IP地址。



#### 7. 为什么DNS采用UDP协议而不采用TCP?

因为UDP更快，UDP只要一个请求一个应答，不像TCP要三次握手。

但UDP传输内容不超过512字节，这对域名来说足够了。



#### 8. **说说 WebSocket 与 Socket 的区别？**

- Socket 其实就是等于 **IP 地址 + 端口 + 协议**。

  具体来说，Socket是一套标准，它完成了对TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。

- WebSocket 是一个持久化的协议，它是伴随 HTML5 而出的协议，用来解决 **http 不支持持久化连接**的问题。
- Socket 一个是**网编编程的标准接口**，而 WebSocket 则是应用层通信协议。



#### 9. **说一下你了解的端口及对应的服务？**

![img](https://pica.zhimg.com/80/v2-c83b44f2fa3c1b415a26de895ee4c141_720w.webp?source=1940ef5c)

#### **10. 说一下HTTP协议？**

HTTP全称是Hyper Text Transfer Protocol. 即超文本传输协议，它是以**TCP/IP**为基础来传输HTML，文件图片等。 它本身处于应用层，端口号80。

- HTTP是基于**浏览器/服务器**架构；
- HTTP是**无状态**协议：HTTP本身并不保存用户的任何信息，也不会对传输的数据，状态信息进行持久化；
- HTTP是**无连接**协议：每次连接只处理一个请求，服务器处理完用户请求，即断开连接，借此节约传输时间。

可以继续作答，把知道的都说出来。



有无状态就是有无记忆性，能不能存储；

可靠性就是传输丢失的问题



#### 11. **说说 HTTP 常用的状态码及其含义？**

- **1xx（信息性状态码）： 表示服务器正在处理请求并需要进一步操作。**
  100 Continue：请求已收到，客户端应继续发送请求的剩余部分。
  101 Switching Protocols：服务器将使用不同的协议进行通信，例如切换到WebSocket。
- **2xx（成功状态码）： 表示请求已成功被服务器接收、理解和处理。**
  200 OK：请求成功，服务器返回所请求的数据。
  201 Created：请求已成功并在服务器上创建了资源。
  204 No Content：请求成功，但服务器没有返回内容。
- **3xx（重定向状态码）： 表示需要进一步操作才能完成请求。**
  301 Moved Permanently：永久重定向：会缓存
  302 Found： 临时重定向：不会缓存
  304 Not Modified：协商缓存命中
- **4xx（客户端错误状态码）： 表示客户端的请求存在问题，导致服务器无法处理请求。**
  400 Bad Request：请求无效，可能由于语法错误等问题。
  401 Unauthorized：请求需要身份验证或令牌无效。
  403 Forbidden：服务器理解请求，但拒绝执行请求。服务器禁止访问
  404 Not Found：请求的资源不存在。
- **5xx（服务器错误状态码）： 表示服务器在处理请求时遇到了错误。**
  500 Internal Server Error：服务器内部错误，无法完成请求。
  502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效响应。
  503 Service Unavailable：服务器繁忙
  504 Gateway Timeout：服务器作为网关或代理，无法及时从上游服务器接收响应。

**说一下301和302的区别？**

- 301:永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。
- 302:临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。



#### 12. **HTTP 有哪些请求方式？**

![img](https://pic1.zhimg.com/80/v2-6a025d8879e89b43431f858b08254bce_720w.webp?source=1940ef5c)

其中，POST、DELETE、PUT、GET的含义分别对应我们最熟悉的增、删、改、查。



#### 13. **说⼀下 GET 和 POST 的区别？**

可以从以下几个方面来说明GET和POST的区别：![img](https://picx.zhimg.com/80/v2-a642aa5c55a469828b34a8b97d24f55b_720w.webp?source=1940ef5c)

1. **从HTTP报文层面来看**，**GET请求将信息放在URL**，**POST将请求信息放在请求体中**。这一点使得GET请求携带的数据量有限，因为URL本身是有长度限制的（**本身没有限制，浏览器限制了**），而POST请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET请求把数据放URL上不太安全，而POST请求把数据放在请求体里想比较而言安全一些。

2. **从数据库层面来看**，GET符合**幂等性**和安全性，而POST请求不符合。这个其实和GET/POST请求的作用有关。按照HTTP 的约定，GET请求用于查看信息，**不会改变服务器上的信息**；而POST请求用来改变服务器上的信息。正因为GET请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据。

   所谓幂等性：

   调用方，对一个系统进行**重复调用**（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果。就是不论调用我多少次你对我的影响以及你的影响都是不变的，不会随着次数的变化而改变。

3. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。缓存是GET请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的GET请求都被CDN缓存起来了，大大减少了 Web 服务器的负担。
4. 其他方面，GET比POST快，因为post请求包含更多的请求头。post能发送更多的数据类型（**get只能发送ASCII字符**）



#### 14. **GET 的长度限制是多少？**

GET请求信息放在URL中，不同浏览器对于URL长度的限制也不一样。（HTTP协议并没有对GET的长度限制，只是浏览器限制了URL的长度，从而限制了GET的长度）。

例如**IE浏览器对URL的最大限制是2000多个字符**，大概2kb左右，像Chrome、Firefox等浏览器支持的URL字符数更多，其中**FireFox中URL的最大长度限制是65536个字符**，**Chrome则是8182个字符**。
这个长度限制也不是针对数据部分，而是针对整个URL。



#### 15. HTTP通信过程？（或者：**HTTP 请求的过程与原理？**）

![img](https://picx.zhimg.com/80/v2-33b69182639b1f17190e1310e9ab283b_720w.webp?source=1940ef5c)

本质上就是上面的**从浏览器地址栏输入 url 到显示主页的过程？**，只不过第一步就是输入URL而已。



#### 16. **说一下HTTP的报文结构？**

HTTP报文有两种，HTTP请求报文和HTTP响应报文：

**HTTP请求报文包括：请求行，首部行，空行和请求体**

```cpp
//请求行 
GET http://www.example.com/ HTTP/1.1
//首部行
 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp
 Accept-Encoding: gzip, deflate
 Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
 Cache-Control: max-age=0
 Host: www.example.com
 If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
 If-None-Match: "3147526947+gzip"
 Proxy-Connection: keep-alive
 Upgrade-Insecure-Requests: 1
 User-Agent: Mozilla/5.0 xxx
 //空行

 //请求体
 param1=1&param2=2
```

请求行包含三个字段：

- 方法字段：包括POST、GET等请方法;
- URL 字段；
- HTTP 版本字段。



**HTTP请求报文包括：状态行，首部行，空行和响应体**

```CPP
//状态行 
HTTP/1.1 200 OK
//首部行
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT
//空行

//实体体
 <!doctype html>
 <html>
 <head>
     <title>Example Domain</title>
     // 省略... 
 </body>
 </html>
```

状态行包含三个字段：

- HTTP 版本字段；
- 状态码；
- 描述。



#### 17. **URI 和 URL 有什么区别?**

![img](https://picx.zhimg.com/80/v2-0892ead17958c187886b9d0e42d4ce07_720w.webp?source=1940ef5c)

- URI，统一资源标识符(Uniform Resource ldentifier，URl)，标识的是Web上每一种可用的资源，如HTML文档、图像、视频片段、程序等都是由一个URI进行标识的。
- URL，统一资源定位符(Uniform Resource Location)，它是URI的一种子集，主要作用是提供资源的路径。

它们的主要区别在于，URL除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人——人类住址协议:/地球/中国/北京市/海淀区/xx职业技术学院/14号宿舍楼/525号寝/张三.男。



#### 18. 说下 HTTP/1.0，1.1，2.0 的区别？

关键需要记住 **HTTP/1.0** 默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用**多路复用**。

**HTTP/1.0**

默认使用短连接，每次请求都需要建立一个TCP连接。它可以设置Connection: keep-alive这个字段，强制开启长连接。

**HTTP/1.1**

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用。
- 分块传输编码，即服务端每产生一块数据，就发送一块，用”流模式”取代”缓存模式”。
- 管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。

**HTTP/2.0**

- 二进制协议，1.1版本的头信息是文本(ASCIl编码)，数据体可以是文本或者二进制；2.0中，头信息和数据体都是二进制。
- 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序——对应。
- 报头压缩，HTTP协议不带有状态，每次请求都必须附上所有信息。Http/2.0引入了头信息压缩机制，使用gzip 或compress压缩后再发送。
- 服务端推送，允许服务器未经请求，主动向客户端发送资源。



#### 19. HTTP/3了解吗？

HTTP/3主要有两大变化，**传输层基于UDP**、使用**QUIC保证UDP可靠性**。

HTTP/2存在的一些问题，比如重传等等，都是由于TCP本身的特性导致的，所以HTTP/3在QUIC的基础上进行发展而来，QUIC (Quick UDP Connections)直译为快速UDP网络连接，底层使用UDP进行数据传输。
HTTP/3主要有这些特点:

- 使用UDP作为传输层进行通信
- 在UDP的基础上QUIC协议保证了HTTP/3的安全性，在传输的过程中就完成了TLS加密握手
- HTTPS 要建立一个连接，要花费6次交互，先是建立三次握手，然后是TLS/1.3的三次握手。QUIC直接把以往的TCP和TLS/1.3的6次交互合并成了3次，减少了交互次数。
- QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。

![img](https://pic1.zhimg.com/80/v2-3185bdece77c9ff25720a1466f04c824_720w.webp?source=1940ef5c)



#### 20. **HTTP长连接和短连接的区别？**

**什么是HTTP的长连接？**

- HTTP分为长连接和短连接，本质上说的是TCP的长短连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP 连接才具有真正的长连接和短连接这一说法。
- TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS/CSS。

在HTTP/1.0中采用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务中断连接；Connection: close

在HTTP/1.1默认采用长连接。Connection: keep-alive，就是保持连接。

**如何设置长连接？**

通过在头部（请求和响应头）设置Connection字段指定为keep-alive ，HTTP/1.0协议支持，但是是默认关闭的，从HTTP/1.1以后，连接默认都是长连接。

**长连接短连接的使用场景？**

长连接适用的场景：长连接适用于操作频繁/点对点通讯等连接数不太多的情况，如：一些游戏/即时通讯场景应该使用长连接；

短连接适用的场景： 短连接适用于大量连接的场景，如Web【wapWeb/H5等】的http服务，长连接对于服务端来说会耗费一定资源。



#### 21. 说说 HTTPS 协议？

HTTPS （全称：Hyper Text Transfer Protocol Secure），是一种透过计算机网络进行**安全通信**的传输协议。HTTPS 经由 HTTP 进行通信，但利用 **SSL/TLS** 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的**身份认证，保护交换数据的隐私与完整性**。



#### 22. 说说**HTTP 与 HTTPS 有哪些区别？**

1. HTTP是超文本传输协议，信息是**明文传输**，存在**安全风险**的问题。HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。
2. HTTР连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而 HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输。所以HTTP响应比HTTPS快。
3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
4. HTTPS 协议需要向 CA（**证书权威机构**）申请数字证书，来保证服务器的身份是可信的。



#### 23. 为什么要用HTTPS？解决了哪些问题？

因为HTTP 是明⽂传输，存在安全上的风险：

**窃听⻛险**，⽐如通信链路上可以获取通信内容，用户账号被盗。

**篡改⻛险**，⽐如强制植⼊垃圾⼴告，视觉污染。

**冒充⻛险**，⽐如冒充淘宝⽹站，用户金钱损失。

![img](https://pic1.zhimg.com/80/v2-eac36c48e89a520358330c707c07d79e_720w.webp?source=1940ef5c)

#### 24. **HTTPS工作流程是怎样的？**

这道题有几个要点：**公私钥、数字证书、加密、对称加密、非对称加密**。

HTTPS 主要工作流程：

1. 客户端发起 HTTPS 请求，连接到服务端的 443 端口。
2. 服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。
3. 服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
5. 客户端将公钥加密后的密钥发送到服务器。
6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，这样传输的数据都是密文。
7. 服务器将加密后的密文返回到客户端。
8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

![img](https://picx.zhimg.com/80/v2-0d85a0965613629cfe13eb141b480c95_720w.webp?source=1940ef5c)



#### 25. 非对称加密和对称加密对比

1. 对称加密是一个秘钥，非对称加密是一对，两个秘钥（通常来说是一个公钥和一个私钥）；
2. 非对称加密比起对称加密更安全，因为不存在秘钥泄露问题，公钥即便被知道也没关系；
3. 由于使用非对称加密在计算上特别复杂，所以一般来说对称加密的加密解密的速度相对于非对称加密快很多；
4. 非对称秘钥还可以用于认证。

**对称加密**：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES等。

![img](https://picx.zhimg.com/80/v2-038820cca5445665414a6cb585336775_720w.webp?source=1940ef5c)

**非对称加密**：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。



#### 26. 客户端怎么去校验证书的合法性？

1. **获取服务器证书**：客户端首先从服务器端获取证书，通常是在握手阶段通过TLS/SSL协议获取的。
2. **验证证书的颁发者**：客户端需要验证证书的颁发者是否是一个受信任的证书颁发机构（CA，Certificate Authority）。这可以通过检查证书链中的根证书来实现。
3. **检查证书的有效期**：客户端需要检查证书的有效期，确保证书在有效期内。
4. **检查域名匹配**：客户端需要检查证书中的域名是否与连接的服务器域名匹配，以防止中间人攻击（Man-in-the-Middle）。
5. **验证证书吊销状态**：客户端可以检查证书吊销列表（CRL，Certificate Revocation List）或使用在线验证方法（OCSP，Online Certificate Status Protocol）来验证证书的吊销状态。
6. **检查扩展信息**：客户端可以检查证书的扩展信息，如主题备用名称（Subject Alternative Name）等，以提高证书校验的准确性。
7. **使用公钥进行加密通信**：一旦验证通过，客户端使用服务器证书中的公钥来加密通信数据。
8. **持久化校验结果**：客户端可以在第一次成功验证后，将服务器的证书信息持久化保存，以便后续连接时进行快速验证。



#### 27. **如何理解 HTTP 协议是无状态的？**

这个无状态的的状态值的是什么？是客户端的状态，所以字面意思，就是HTTP协议中服务端不会保存客户端的任何信息。

比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。

追问：**那有什么办法记录状态呢？**

主要有两个办法，**Session和Cookie**。



#### 28. 一个特别宽泛的问题，你怎么理解HTTP或者HTTP是用来干嘛的?

**HTTP的本质**

HTTP是一个协议，是一个**超文本传输协议**

它基于 TCP/IP 来传输文本、图片、视频、音频等。

HTTP不是管道的功能，不提供数据包的传输功能，也就是数据包从浏览器到服务端再来回的**传输**和它没关系，这是TCP/IP干的。

所以HTTP本质就是**客户端和服务端约定好的一种通信格式**。



#### 29. HTTP缓存了解吗？

http缓存指的是: 当客户端向服务器请求资源时，会先抵达**浏览器缓存**，如果浏览器有“要请求资源”的副本，就可以**直接从浏览器缓存中提取**而不是从原始服务器中提取这个资源。

常见的http缓存**只能缓存GET请求**响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。

http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

HTTP 缓存又分为**强缓存**和**协商缓存**：

**强制缓存**：在缓存数据未失效的情况下，那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求，直接返回200。

**协商缓存**：当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时（即不走强缓存），那么浏览器第二次请求时就会与服务器进行**协商**，与服务器端对比判断资源是否进行了修改更新。



#### 30. 说说Session 和 Cookie 有什么联系和区别?

Session和Cookie的作用是解决HTTP协议无状态的特性，一句话来说，就是为了存储客户的状态。这就是二者的联系。

先来看看什么是Session和Cookie ：

- Cookie是**保存在客户端的一小块文本串的数据**。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务端可以根据这个Cookie判断用户的身份和状态。
- Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。**不同的是cookie保存在客户端浏览器中，而session保存在服务器上**。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。

![img](https://picx.zhimg.com/80/v2-495d2526efabdd28badf09d27959f3a4_720w.webp?source=1940ef5c)

**二者的区别：**

- 存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。
- 存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。

**二者的关联：**

可以使用Cookie记录Session的标识。

![img](https://picx.zhimg.com/80/v2-517a536b1c871a5203a184b5a336c9fa_720w.webp?source=1940ef5c)

- 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的Session，请求返回时将此Session 的唯一标识信息SessionID返回给浏览器，浏览器接收到服务器返回的SessionID信息后，会将此信息存入Cookie 中，同时Cookie记录此SessionID是属于哪个域名。
- 当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie 信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie 中获取 SessionID，再根据SessionlD查找对应的Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。

**分布式环境下Session怎么处理呢？**

分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的Session。

这个时候可以使用**Redis**等分布式缓存来存储Session，在多台服务器之间共享。

**客户端无法使用Cookie怎么办？**

有可能客户端无法使用Cookie，比如浏览器禁用Cookie，或者客户端是安卓、IOS等等。

这时候怎么办？SessionID怎么存？怎么传给服务端呢？

首先是SessionID的存储，可以使用客户端的本地存储，比如浏览器的sessionStorage。

接下来怎么传呢？

- 拼接到URL里：直接把SessionID作为URL的请求参数
- 放到**请求头**里：把SessionID放到请求的Header里，比较常用。



### 传输层

#### **31. TCP是什么？**

TCP（传输控制协议）是一种**面向连接**、**可靠的**、**基于字节流**的**传输层协议**。



#### 32. **TCP首部由哪些部分组成**?

1. **源端口**，16位；

2. **目的端口**，16位；

3. 发送数据包中第一个字节的**序列号seq**，32位；

4. **确认序列号ACK**，32位；

5. **数据偏移**，4位，该字段的值是TCP首部（包括选项）长度除以4；

6. **标志位（竖着读）**： 6位；

   URG表示Urgent Pointer字段有意义：
   ACK表示Acknowledgment Number字段有意义
   PSH表示Push功能，RST表示复位TCP连接
   SYN表示SYN报文（在建立TCP连接的时候使用）
   FIN表示没有数据需要发送了（在关闭TCP连接的时候使用）

7. 窗口大小**表示接收缓冲区的空闲空间**，16位，用来告诉TCP连接对端自己能够接收的最大数据长度；

8. Checksum是**校验和**，16位；

9. Urgent Pointers是紧急指针，16位，只有URG标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。

   ![img](https://pic3.zhimg.com/80/v2-cd99b7b828dd11c0e3f39f79fd91490e_720w.webp)



#### 33. 详细说一下TCP的三次握手机制

**【答题的时候注意关键细节要说出来，比如SYN标志位，seq序列号还有SYS_SENT状态等。】**

![1691742863383](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691742863383.png)

**三次握手：**

先说明几个点：

SYN是请求报文或者请求确认报文的标志，ACK表明该报文是确认报文段，seq是客户端或者服务端选择的初始序号，ack是确认号字段，表明对之前数据的确认以及期望接受到的数据。

SYN被设置位1的报文段不能携带数据，但是要消耗掉一个序号；普通的确认报文段（没有SYN位）可以携带数据，如果不携带数据的话，就不消耗一个序号，下一次还是和只一次的seq相同。

- **初始状态**：客户端处于 close(关闭)状态，服务器处于 listen(监听) 状态。

- **第一次握手**：客户端发送请求报文将SYN设置为1和初始化序列号seq=x发送给服务端，发送完后客户端处于同步已发送SYN_SENT状态。

- **第二次握手**：服务器收到来自客户端的SYN请求报文后，如果同意连接，就需要向客户端发送请求确认报文段。发送的内容包括，SYN=1（表示是请求报文），确认标志ACK=1（表示确认报文段），初始序号seq=y以及ack（表示对客户端的数据的确认，以及期望下一次收到的数据包）发送给客户端。发送完后，服务端处于同步已接收SYN_RCVD状态。

  （问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）

- **第三次握手**：客户端收到来自服务端的SYN+ACK之后，知道可以发送下一序列的数据包了，此时发送的就是一个普通的报文段，不需要SYN了。发送的内容包括确认标志ACK=1，s初始化序列seq=x+1，因为请求报文段已经消耗了一个序号，这里需要加1，ack=y+1，这是对服务端的数据确认以及希望接下来收到的数据。客户端状态变为连接已建立ESTABLISTED状态，服务端收到之后也变为ESTABLISTED状态。



#### 34. **TCP 握手为什么是三次，为什么不能是两次？不能是四次？**

**为什么不能是两次？**

- 为了防止服务器端开启一些无用的连接增加服务器开销；
- 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

![img](https://picx.zhimg.com/80/v2-acc99979a7cd4bb915da80bb1e08356e_720w.webp?source=1940ef5c)

第一种情况的意思是如果服务器发送给客户端的请求确认报文丢失了，那么客户端在收不到请求报文的情况下，就会超时重传，此时就会由服务器的另一个端口来处理，但是服务器的上一个端口由于没有收到来自客户端的消息，就会一直处于被占用的状态，最终可能会开启很多无用的端口。

![1691744695493](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691744695493.png)

第二种情况的意思是，客户端发送的请求报文由于某种情况滞留了，客户端在收不到服务端回应的情况下会超时重传，如果是两次握手的话，并且二者的信息都不丢失，是可以完成此次数据传输的，传输完成后客户端处于关闭状态。此时如果之前的请求报文来了，服务端会以为是新的报文，然后会发送请求确认给客户端，但是客户端已经关了。就会造成服务端的资源浪费。

第三次握手的目的，就是客户端给服务端一个响应，告诉服务端，你的发送是没问题的。然后就可以进入发送数据的阶段了。

**为什么不能是四次？**

三次已经足够建立连接了，不需要额外的过程了，只会浪费资源。



#### 35. **第二次握手传回了 ACK，为什么还要传回 SYN？**

ACK是为了告诉客户端传来的数据已经接收无误。

而传回SYN是为了告诉客户端，服务端响应的确实是客户端发送的报文。



#### 36. **第3次握手可以携带数据吗？**

第3次握手是可以携带数据的。因为第三次发送的是普通报文，是可以携带数据的，如果不携带数据的话，是不会消耗序号的。这与请求报文不一样，请求报文不能携带数据，这是出于安全的考虑，如果允许携带数据，攻击者每次在SYN报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成CPU和内存的消耗。



#### 37.  **说说半连接队列和 SYN Flood 攻击的关系？**

**什么是半连接队列？**

TCP进入三次握手前，服务端会从**CLOSED**状态变为**LISTEN**状态,同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）。

![img](https://pic1.zhimg.com/80/v2-c7fde3d069eda1cf00984f19bdc691eb_720w.webp?source=1940ef5c)

顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。

- TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复ACK和SYN，状态由LISTEN 变为SYN_RCVD，此时这个连接就被推入了SYN队列，即半连接队列。
- 当客户端回复 ACK,服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。

**什么是SYN Flood？**

SYN Flood 是一种典型的 DDos （D-Dos）攻击，它在短时间内，伪造**不存在的 IP 地址**, 向服务器发送大量SYN 报文。当服务器回复SYN+ACK之后，不会收到ACK回应报文，那么SYN队列里的连接不会处队列，久⽽久之就会占满服务端的 **SYN** 接收队列（半连接队列），使得服务器不能为正常⽤户服务。

![img](https://pica.zhimg.com/80/v2-76d044e76bc209158e75b71c9f923de9_720w.webp?source=1940ef5c)

**那有什么应对方案呢？**

主要有 **syn cookie** 和 **SYN Proxy 防火墙**等。

- **syn cookie**：在收到SYN包后，服务器根据一定的方法，以数据包的**源地址**、**端口**等信息为参数计算出一个cookie值作为自己的 SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，**等收到发送方的ACK包后**，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。（相当于自己多个心眼）
- **SYN Proxy防火墙**：服务器防火墙会对收到的每一个SYN报文进行**代理和回应**，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。（相当于是请人帮忙）



#### 38. **说说 TCP 四次挥手的过程？**

PS：问完三次握手，常常也会顺道问问四次挥手，所以也是必须掌握知识点。

![1691753680513](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691753680513.png)

数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起，其中FIN是释放连接请求标志。

- 客户端发送释放连接报文，**第一次挥手** (FIN=1，seq=u)，发送完毕后，客户端进入 **FIN_WAIT_1**（中止等待1） 状态。

- 服务端发送确认报文，**第二次挥手** (ACK=1，ack=u+1, seq =v)，发送完毕后，服务器端进入**CLOSE_WAIT** 状态，客户端接收到这个确认包之后，进入 **FIN_WAIT_2** （终止等待2）状态。

  此时这个情况，客户端已经将所有的数据发送完毕了（因为是客户端主动发起断开连接请求的），但是服务端可能还没有发送完所有的数据，所以服务端需要将剩余的数据都发送完毕。

- 当服务端数据发送完毕之后，就需要发送释放连接报文，**第三次挥手** (FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入 **LAST_ACK** （最后确认）状态。
- 客户端发送确认报文，**第四次挥手** (ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，**等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后**，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。



#### 39. TCP挥手为什么需要四次呢？

因为TCP连接是**全双工**的，**每个方向需要单独关闭**，发送FIN标志。需要双方都断开。

第一次挥手是客户端告诉服务端自己想断开连接，第二次是挥手是表明服务器端知道了，但是自己还有东西要传，所以就先回应一下，第三次是服务端完成了自己的事情，给客户端发送了关闭连接，此时还没关闭，还在等客户端那边的说法，第四次挥手是客户端最后发给服务端的，服务端收到之后就直接关闭，然后客户端等待2MSL之后才关闭。



#### 40. **TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？**

- 为了**保证客户端发送的最后一个ACK报文段能够到达服务器**。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。**假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。**
- 如果不等待的话直接关闭的话，假设客户端在之前的端口又开启了新的连接，并且之前传的ACK丢失了，此时服务端会重传FIN到这个端口，将产生不可预期的错误。



#### 41. 为什么是2MSL呢，不能是其他时间吗？

可以，2MSL是一个最保守的时间，是一个最大的时间。

MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长间，超过这个时间报文将被丢弃。如果A是主动断开的一方，B是被动断开的一方。B干完自己的事情后，发送了FIN+ACK给A，但是自己也不能马上关闭。A收到FIN之后，就发送ACK给B。

但，A并不知道B是否接到自己的ACK，A是这么想的：

1.如果B没有收到自己的ACK，会超时重传FiN，那么A再次接到重传的FIN，会再次发送ACK

2.如果B收到自己的ACK，也不会再发任何消息，包括ACK

无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：

**去向ACK消息最大存活时间**（1MSL) + **来向FIN消息的最大存活时间**（1MSL）,加在一起也就是2MSL。



#### 42. **CLOSE-WAIT 和 TIME-WAIT 的状态和意义？**

**CLOSE-WAIT 的意义：**

服务端收到客户端关闭连接的请求并确认之后，就会进入CLOSE-WAIT状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT状态就是为了保证服务端在关闭连接之前将待发送的数据处理完。

**TIME-WAIT有什么意义？**

TIME-WAIT状态发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入TIME-WAIT状态。

![img](https://picx.zhimg.com/80/v2-64ae4af0cde76de32414864798e67e98_720w.webp?source=1940ef5c)

40题中已经做了回答。



#### 43. **TCP 是如何保证可靠性的？**

TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。![img](https://picx.zhimg.com/80/v2-d6debf29fa2b9a9f0d3101df170b4a21_720w.webp?source=1940ef5c)

1. **连接管理：**TCP使用三次握手和四次挥手保证可靠地建立连接和释放连接，这里就不用多说了。
2. **检验和：**TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。![img](https://pic1.zhimg.com/80/v2-26e56e41336cd27313559027e94fa6c8_720w.webp?source=1940ef5c)

3. **序列号/确认应答：** 序列号/确认应答:TCP给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。

   ![img](https://picx.zhimg.com/80/v2-b22b73d35d101abe11345b9f94aa163a_720w.webp?source=1940ef5c)

4. **流量控制：** TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示**发送方降低发送的速率**，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）。![img](https://pic1.zhimg.com/80/v2-4a7565f4307b0532908737caa6b2171a_720w.webp?source=1940ef5c)

5. **最大消息长度：** 在建立TCP连接的时候，双方约定一个最大的长度(MSS)作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。

   ![img](https://picx.zhimg.com/80/v2-9d6e2fa7ba11c930ee6e4c7629a8c062_720w.webp?source=1940ef5c)

6. **超时重传：** 超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。

   ![img](https://picx.zhimg.com/80/v2-6b7a868c19dd9d12557360af5d16055b_720w.webp?source=1940ef5c)

7. **拥塞控制：** 如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。

   ![img](https://picx.zhimg.com/80/v2-27afcfa27213d21a5312dbf76d33839f_720w.webp?source=1940ef5c)



#### 44. **说说 TCP 的流量控制？**

所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便在TCP连接上实现对发送方的流量控制。

TCP 通过**滑动窗口**来控制流量，我们看下简要流程：不考虑拥塞的情况。

滑动窗口发一句等一句回答，而是可以发送最大窗口长度的数据，这就是滑动窗口的作用。

![1691760283121](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691760283121.png)

下面根据这个例子来详细说一下TCP的流量控制。首先假设发送方有1000字节的报文需要发送，1个TCP报文段的长度是100个字节。

1. 假设接收方的滑动窗口大小为400，此时**发送方的滑动窗也设置为400**；
2. 发送方在没有收到接收方的反馈信息之前，可以将**滑动窗中的数据全部发送出去**；
3. 假设发送方在发送了2个报文段，即200个字节的数据之后，收到了来自接收方对于前200个数据的确认信息，以及接收方滑动窗**调整为300的信息**；
4. 接收方首先**将200个字节的数据移出滑动窗**，然后滑动窗向前移动，并根据接受窗的大小调整为300，发送方此时滑动窗里面的数据为200-500；
5. 接下来发送方继续发送数据，正好将滑动窗中的数据发送完之后，收到了来自接收方的**前500数据的确认**，以及将滑动窗大小**调整为0**，此时接收方将窗中的300个数据全部移出，表明已经发送完毕，并将窗长设置为0。

这就是一个简单的流量控制的过程。

在上面的流程中，**可能会出现TCP的死锁**。如果有一个时刻，接收方的窗长不为0了，接收方将这个报文传给发送方，但是这个报文丢失了，与此同时，接收方也在等待发送方的窗长不为0的报文，接收方等待来自发送方的数据，二者就陷入了死锁。

解决这个问题的方案就是使用**持续计时器**，具体而言就是发送方在收到零窗口报文之后，会启动一个持续计时器，当计时器时间到了，会发送一个携带一字节数据零窗口探测报文，其功能就是查询接收窗的长度是否为0。若不为零，接收方就发送携带窗长的报文给发送方，否则就发送窗长为0的报文给接收方。接收方收到之后，又将启动持续计时器。

**问：零窗口探测报文丢了怎么办？**

零窗口探测报文也有超时重传计时器

**问：窗长都为0了，还能接收零窗口探测报文吗？**

可以，TCP归定，即使窗长为0，也可以接收零窗口探测报文以及紧急报文。



#### 45. **了解Nagle 算法和延迟确认吗？**

**Nagle 算法和延迟确认是干什么的？**

当我们TCP报文的承载的数据非常小的时候，例如几个字节，那么整个网络的效率是很低的，因为每个TC报文中都会有20个字节的TCP头部，也会有20个字节的IP头部，而数据只有几个字节，所以在整个报文中有效数据占有的比例就会非常低。

![img](https://picx.zhimg.com/80/v2-33f6871f1791f53700e1e648516c33fb_720w.webp?source=1940ef5c)

那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：

- Nagle 算法
- 延迟确认

**Nagle 算法**

Nagle算法：**任意时刻，最多只能有一个未被确认的小段**。所谓“小段”，指的是小于MSS(最大报文长度)尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

Nagle 算法的策略：

- 没有已发送未确认报⽂时，⽴刻发送数据。
- 存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS 大小」时，再发送数据。

只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在**囤积数据**，直到满⾜上⾯的发送条件。

**延迟确认**

事实上当没有携带数据的ACK，它的网络效率也是很低的，因为它也有40个字节的IP头和TCP头，但却没有携带数据报文。为了解决 ACK 传输效率低问题，所以就衍⽣出了 **TCP** 延迟确认。

TCP 延迟确认的策略：

- 当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅；
- 当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送；
- 如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK。

一般情况下，**Nagle 算法和延迟确认**不能一起使用，Nagle 算法意味着延迟发，**延迟确认**意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。



#### 46. **说说TCP 的拥塞控制？**

**什么是拥塞控制？不是有了流量控制吗？**

前⾯的流量控制是**避免发送方的数据填满接收方的缓存**，但是并不知道整个网络之中发⽣了什么。

⼀般来说，计算机网络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时TCP就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....

于是，就有了拥塞控制，控制的⽬的就是**避免发送方的数据填满整个网络**。

发送方维护一个**拥塞窗口 cwnd（congestion window）** 的变量，调节所要发送数据的量。



#### 47. **什么是拥塞窗口？和发送窗口有什么关系呢？**

拥塞窗口**cwnd**是发送⽅维护的⼀个的状态变量，它会根据网络的拥塞程度动态变化的。

发送窗swnd和接收窗口rwnd是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是**swnd = min(cwnd, rwnd)**，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗⼝ cwnd 变化的规则：

- 只要⽹络中没有出现拥塞， cwnd 就会增⼤；
- 但⽹络中出现了拥塞， cwnd 就减少； 

发送方判断==**网络拥塞的依据**==：没有按时收到应当到达的确认报文（即发生超时重传）

拥塞控制主要有这几种常用算法：

- ==慢开始==
- ==拥塞避免==
- ==快重传==
- ==快恢复==



#### 48. 详细说一下拥塞控制的几种算法

我们假设接收方的缓存足够大，那么发送窗口只取决于拥塞窗口。

发送方维护一个**==慢开始门限ssthresh==**状态变量：

- 当cwnd  < ssthresh时，使用慢开始算法；
- 当cwnd  > ssthresh时，停止使用慢开始算法改而使用拥塞避免算法；
- 当cwnd  = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法。

举个例子：

- 我们首先将慢开始门限设置为16，拥塞窗口设置为1，此时由于拥塞窗口小于慢开始门限，**==执行慢开始算法==**，并发送一个数据报文段（等于拥塞窗口大小）；
- 当收到第一个报文段的确认后，说明网络没有发生拥塞，此时慢开始算法将拥塞窗口设置为2，然后发送接下来的2个报文；
- 在收到接下来两个报文的确认后，此时慢开始算法将拥塞窗口设置为4，然后发送接下来的4个报文，以此类推
- 直到拥塞窗口到达慢开始门限16，转而执行**==拥塞避免算法==**，将后16个报文段发送出去，如果接收到了16个报文的确认，就将拥塞窗口增加1（线性增加，之前是指数增加）；
- 如果在某一次收到的确认报文中没有包含发送报文的确认，此时网络就会发生超时重传，说明网络发生了拥塞，就会执行如下的操作：
  1. 首先将慢开始门限设置为当前拥塞窗口的一半；
  2. 然后将拥塞窗口设置为1；
  3. 继续执行慢开始算法以及拥塞避免算法

![1691804634264](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691804634264.png)

注意：

- “慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；
- “拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。



**快重传算法：**

问题描述：

有时，**个别报文段**会在网络中**丢失**，但实际上网络**并未发生拥塞**。

- 这将导致发送方超时重传，并误认为网络发生了拥塞；
- 发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。

采用快重传算法可以**让发送方尽早知道发生了个别报文段的丢失**。

所谓快重传，就是使发送方**尽快进行重传**，而**不是等超时重传计时器超时**再重传。

- 要求接收方不要等待自己发送数据时才进行捎带确认，而是要**立即发送确认**；
- 即使收到了失序的报文段（**说明有报文丢失了**）也要立即发出对已收到的报文段的重复确认；
- 发送方一旦收到**3个连续的重复确认**，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传；
- 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1)。 

![1691805435868](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691805435868.png)



**快恢复算法：**

发送方一旦**收到3个重复确认**，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而**执行快恢复算法**

具体而言：

发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为**当前窗口的一半**；开始执行拥塞避免算法。

也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的**ssthresh + 3**。

- 既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；
- 这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；
- 可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。

![1691805879688](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691805879688.png)



#### 49. **什么情况下开始减慢cwnd增长速度？**

cwnd为拥塞窗口。

采用慢开始和拥塞避免算法的时候：

1. 一旦**拥塞窗口达到慢启动阈值**，就采用**拥塞避免**算法，减慢增长速度；
2. 一旦出现**丢包**的情况，就重新进行慢开始，减慢增长速度。

采用快恢复和快重传算法的时候：

1. 一旦**拥塞窗口达到慢启动阈值**，就采用拥塞避免算法，减慢增长速度；
2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度。



#### 50. 说说TCP的重传机制

重传包括**超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种**。

![img](https://picx.zhimg.com/80/v2-ef77bf8bd7da91efa048c71481970654_720w.webp?source=1940ef5c)

- **超时重传**

  超时重传，是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。

  **超时时间应该设置为多少呢？**

  一般来说，超时重传时间RTO设置为略微大于RTT，效果是最佳的，其中RTT代表的是往返时间。

  ![img](https://pic1.zhimg.com/80/v2-6a1ab77d4e0acf33ff38cc8d13c62fff_720w.webp?source=1940ef5c)

  超时重传不是十分完美的重传方案，它有这些缺点：

  - 当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。
  - 当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。



- **快速重传**

  就是上面提到的拥塞控制的方法，如果收到的报文不是按序到达的，就会重传之前的确认。三次重复确认之后就会重发丢失的报文。

  但是使用上面两种重传算法都不知道该重传哪一个包，素以需要带选择确认的重传，可以对已经收到的包进行确认，然后再重传丢失的包。



#### 51. **说说TCP 的粘包和拆包？**

**什么是TCP粘包和拆包？**

TCP是面向流，没有界限的一串数据。TC底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCР拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TC粘包和拆包问题。

![img](https://pica.zhimg.com/80/v2-5cd3a3d4b45eb7909ccaf63dd742536e_720w.webp?source=1940ef5c)

**为什么会产生粘包和拆包呢?**

- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；
- 待发送数据大于MSS(最大报文长度)，TCP在传输前将进行拆包。即TCP 报文长度–TCP头部长度>MSS。

**如何解决？**

- 发送端将每个数据包封装为固定长度；
- 在数据尾部增加特殊字符进行分割；
- 将数据分为两部分，一部分是头部，一部分是内容体;其中头部结构大小固定，且有一个字段声明内容体的大小，可以在一定程度上解决拆包的问题。



#### 52. 网络层到数据链路层的交互过程

网络层到数据链路层，首先是**用MAC地址作为通信目标**。

首先查找**ARP缓存**（IP-MAC对应关系）查找IP对应的MAC地址，如果查到了，就将**IP地址对应的MAC地址封装到包头**。否则发送一个广播，所有接收的主机如果匹配IP，则将自己的MAC地址以单播的形式发送给请求的主机。



#### 53. **请你说说传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文**

根据端口区分应用程序。可以看IP头中的**协议标识字段**，如果是17表示UDP，6表示TCP。



#### 54. **说说 TCP 和 UDP 的区别？**

最根本区别：**TCP 是面向连接，而 UDP 是无连接**。

![img](https://pic1.zhimg.com/80/v2-90d14ee4671384c32c660fe5a1722484_720w.webp?source=1940ef5c)

可以这么形容：TCP是打电话，UDP是大喇叭。

下面详细说一下二者的区别：

两者都是传输层协议。

- TCP是**点对点传输**，而UDP可以**一对多**，**多对多**，**多对一**的交互通信；
- 可靠性：TCP是**无差错，不丢失，不重复，按序到达**；UDP是尽最大努力交付；
- 拥塞控制，流量控制：TCP有拥塞控制和流量控制机制；UDP没有。
- 首部开销：
  - TCP为20个字节
  - UDP为8个字节（源端口，目的端口，数据长度，校验和）

- 适用场景：

  tcp适用于**可靠性高**的场景，而udp适用于**实时性**强的场景，具体见下表：

![img](https://pic1.zhimg.com/80/v2-93041ef15eb684aba4992613803a1a98_720w.webp)



#### 55. **为什么QQ采用UDP协议？**

![img](https://picx.zhimg.com/80/v2-429db70b7bcb8db07043d2b0aeb7203c_720w.webp?source=1940ef5c)

- 首先，QQ并不是完全基于UDP实现。比如在使用QQ进行文件传输等活动的时候，就会使用TCP作为可靠传输的保证。
- 使用UDP进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP是一个全双工协议，需要建立连接，所以网络开销也会相对大。
- 如果使用QQ语音和QQ视频的话，UDP的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。
- 由于QQ的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。

简单总结一下: UDP协议是无连接方式的协议，它的**效率高**，**速度快**，**占资源少**，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。



#### 56. **UDP协议为什么不可靠？**

UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：

- 不保证消息交付：不确认，不重传，无超时；
- 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞；
- 不跟踪连接状态：不必建立连接或重启状态机；
- 不进行拥塞控制：不内置客户端或网络反馈机制。



#### 57. **TCP对应的应用层协议**

**FTP**：定义了文件传输协议，使用21端口；

**Telnet**：它是一种用于远程登陆的端口,23端口 ；

**SMTP**：定义了简单邮件传送协议，服务器开放的是25号端口；

**POP3**：它是和SMTP对应，POP3用于接收邮件，端口号110。



#### 58. **UDP对应的应用层协议**

**DNS**：用于域名解析服务，用的是53号端口；

**SNMP**：简单网络管理协议，使用161号端口；

**NFS**：网络文件服务器，具有多个端口111，2049等。



#### 59. DNS为什么要用UDP？

更准确地说，DNS既使用TCP又使用UDP。

当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而TCP允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的TCP。

当客户端想DNS服务器查询域名(域名解析）的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节，用UDP传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。



### 网络层

#### 60. **网络层有哪些常用协议？**

**IP、ICMP、RIP和IGMP等**

![img](https://pic3.zhimg.com/80/v2-57b90d14f87f3769fe340959eda7ff46_720w.webp)



#### 61. **IP 协议的定义和作用？**

**IP协议是什么？**

IP协议(Internet Protocol)又被称为互联网协议，是支持网间互联的数据包协议，工作在网际层，主要目的就是为了提高网络的可扩展性。

通过**网际协议IP**，可以把参与互联的，性能各异的网络**看作一个统一的网络**。

![img](https://picx.zhimg.com/80/v2-bada2ab6bd629722ccd21a41d25d5139_720w.webp?source=1940ef5c)

和传输层TCP相比，IP协议是一种**无连接/不可靠、尽力而为的数据包传输服务**，和TCP协议一起构成了TCP/IP协议的核心。

**IP协议有哪些作用？**

IP协议主要有以下几个作用：

**寻址和路由**：在IP数据报中携带源IP地址和目的IP地址来表示该数据包的源主机和目标主机。IP数据报在传输过程中，每个中间节点 （IP网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP协议根据路由选择协议提供的路由信息对IP数据报进行转发，直至目标主机。

**分段和重组：** IP数据报在传输的过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP协议通过给每个IP数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段的IP数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作回复出原来地IP数据报。

**传输层协议和网络层协议有什么区别？**（主要回答黑体的部分）

**网络层协议负责提供主机间的逻辑通信**；

其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。

**传输层协议负责提供主机不同应用进程间的逻辑通信。**

传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使高层用户看到的只是在两个传输实体间的一条端到端的、可由用户控制和设定的、可靠的数据通路。



#### 62. **IP 地址有哪些分类？**

一个IP地址在互联网内是唯一的，一般可以将IP地址划分为：IP地址={<网络号>, <主机号>}。

- **网络号**：它标志主机所连接的网络地址表示属于互联网的哪一个网络。
- **主机号**：它标志主机地址表示其属于该网络中的哪一台主机。

IP地址有32位，共4个字节，根据网络号和主机号的不同，可以分为A，B，C，D，E五大类。

![1691827475143](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691827475143.png)

![img](https://picx.zhimg.com/80/v2-59725ad16c2cbc7ad2291fe747a09fc8_720w.webp?source=1940ef5c)

- A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于**大型网络**。

- B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于**中等规模网络**。

- C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于**小型网络**。

- D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于**多路广播用户** 。

- E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。

最小网络号为0，保留不指派；最大网络号为127，作为本地环回测试地址，不指派。

要会计算可指派的网络数量以及可分配的IP地址数量，**==都要减2==**。



#### 63. **域名和 IP 的关系？一个 IP 可以对应多个域名吗？**

域名和IP是映射关系。比如对于百度，其ip地址可能比较难记，不方便客户访问。所以就引入域名地址，也就是www.baidu.com，在浏览器直接输入域名，利用DNS可以解析其对应的IP，然后就可以访问服务器了。

ip地址与**域名**是一对多的关系。一个ip地址可以对应多个域名，但是一个域名只有一个ip地址。ip地址是数字组成的，不方便记忆，所以有了域名，通过域名地址就能找到ip地址。



#### 64. **IPV4 地址不够如何解决？**

**动态分配**

使用 **动态分配** IP 地址：就是当有设备联网的使用分配一个 IP 地址给当前设备，如果当前设备不联网了，那么就不分配。但是这种方案是治标不治本的。

**NAT机制**

使用 NAT 机制：把 IP 分为 **外网 IP** 和 **内网 IP**，用一个 **外网 IP** 代替 **N 个内网 IP**。而进入 **内网 IP** 后则是使用 **端口号** 区分。

**升级 IPv6**

作为接替IPv4的下一代互联网协议，其可以实现2的128次方个地址



#### 65. **说下 ARP 协议的工作过程？**

ARP协议，Address Resolution Protocol，地址解析协议，它是用于实现IP地址到MAC地址的映射。

![img](https://picx.zhimg.com/80/v2-684edb938ad46d4cc42b1efb5a301eb6_720w.webp?source=1940ef5c)

1. 首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
2. 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的ARP列表，是否存在该IP地址对应的MAC地址;如果有﹐就直接将数据包发送到这个MAC地址;如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求的数据包里，包括源主机的IP地址、硬件地址、以及目的主机的I地址。
3. 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同，就会忽略此数据包;如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址。
4. 源主机收到这个ARP响应数据包后，将得到的目的主机的IР地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。



#### 66. **ICMP 协议的功能？**

ICMP（Internet Control Message Protocol） ，网际控制报文协议：

- ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。
- 它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。
- 当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。

比如我们日常使用得比较多的**ping**，就是基于ICMP的。



#### 67. IP和ICMP协议有何区别？

IP协议和ICMP协议都工作于网络层，通常ICMP协议嵌入在IP协议中。IP协议本身不保证可靠性，ICMP是IP协议的一个补充，包括**差错报告**和**询问报告两类。**IP的检验和只计算报文头部，ICMP是计算报文头部和数据主体。

ICMP类型分为两大类：

1. **差错报告**
2. **询问报告**

ICMP通过一个整数数字来表示不同的报文类型，双方通过该类型值来识别报文的目的，并作出不同的反应。

![1691831432137](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691831432137.png)



#### 68. 说一下ping的工作原理，它是基于那一层的协议？

ping是基于**网络层**的**ICMP协议**工作的。

它是一种因特网包探索器，用于测试网络连接量的程序，主要是向**特定的主机发送ICMP请求报文**，测试目的站是否可达以及了解其有关状态。

我们可以举个例子来了解一下ping命令的过程，假设及其**A ping 机器B**：

1. ping 通知系统，新建一个固定格式的 ICMP 请求数据包；
2. ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层；
3. IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包；
4. 先获取目标机器 B 的 MAC 地址；（使用ARP地址解析协议）；
5. 数据链路层构建一个数据帧，目的地址是 IP 层传过来的 **MAC 地址**，源地址是本机的 **MAC 地址**；
6. 机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃；
7. 根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间；
8. 最终显示结果有这几项:发送到目的主机的IP地址、发送&收到&丢失的分组数、往返时间的最小、最大&平均值。



### 数据链路层

#### 68. 数据链路层有哪些协议？

 **ARP 协议**：地址解析协议，其作用是根据IP地址获取MAC地址；

**RARP协议**：反向地址解析协议，根据MAC地址反向获取IP地址；

**PPP协议**：是一种点到点（一根链路两端只有两个接口）链路层协议，主要用于在全双工的同异步链路上进行点到点的数据传输。



追问的问题就是 **65. 说下 ARP 协议的工作过程？**



### 网络安全

#### 69. **说说有哪些安全攻击？**

网络安全攻击主要分为两种类型，**被动攻击**和**主动攻击**：

![img](https://picx.zhimg.com/80/v2-56f63b42ae03ff6cff1023f3f7148ca5_720w.webp?source=1940ef5c)

**被动攻击**：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为**截获**，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。

**主动攻击**：直接对现有的数据和服务造成影响，常见的主动攻击类型有：

- **篡改**：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。
- **恶意程序**：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。
- **拒绝服务Dos（Denial of Service）**：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。



#### 70.  **DNS劫持了解吗？**

DNS劫持即**域名劫持**，是通过将原域名对应的IP地址进行替换，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。

![img](https://pic1.zhimg.com/80/v2-1da48d4d2a1e37e14b758cf0a9c25c8e_720w.webp?source=1940ef5c)

**DNS劫持的步骤是什么样的？**

1. 获取要劫持的域名信息：攻击者会首先访问域名查询要劫持的站点的域名信息；
2. 控制域名响应的E-Mail账号:在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的E-mail账号所对应的密码，更高级的攻击者甚至能够直接对E-Mail进行信息窃取。
3. 修改注册信息:当攻击者破解了E-Mail后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS服务器信息等。
4. 使用E-Mai收发确认函:在修改完注册信息后，攻击者E-Mail在真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成DNS劫持。

**怎么应对DNS劫持？**

1. 直接通过IP地址访问网站，避开DNS劫持;
2. 由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让DNS指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选DNS服务器的地址固定为8.8.8.8。



### 补充

#### 71. 拔掉网线后， 原本的 TCP 连接还存在吗？

这个问题要分场景来讨论：

- 拔掉网线后，有数据传输
- 拔掉网线后，没有数据传输

**==拔掉网线后，有数据传输==**

在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发**超时重传**机制，重传未得到响应的数据报文。

**如果在服务端重传报文的过程中，客户端刚好把网线插回去了**，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 **ESTABLISHED** 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。

但是，**如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去**，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。

**==拔掉网线后，没有数据传输==**

针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。

如果**没有开启** TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会**==一直保持存在==**。

而如果**开启**了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：

- 如果**对端是正常工作**的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 **TCP 保活时间会被重置**，等待下一个 TCP 保活时间的到来。
- 果**对端主机崩溃，或对端由于其他原因导致报文不可达**。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，**TCP 会报告该 TCP 连接已经死亡**。



保活机制的原理：

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。



### socket专题

#### 72. **套接字有哪些类型？**

**流格式套接字**(SOCK_STREAM)：**有连接**的套接字，是基于TCP的套接字。

- 数据在传输过程中**不会消失**；
- 数据是**按照顺序**传输的；
- **没有数据边界**；

**数据报格式的套接字**(SOCK_DGRAM) ：**无连接**套接字，是基于UDP的套接字。

- 强调**快速传输**而非传输顺序；
- 传输的数据**可能丢失**；
- **限制**每次传输的数据大小；
- 有数据边界；



#### 73. **面向连接和无连接的套接字有什么区别。**

面向连接的套接字就是在正式通信之前先要确定一条路径，而无连接套接字不需要。

然后在回答的时候结合72即可。



#### 74. Socket通信流程

在对Socket有了大致了解之后，再来理解Socket的通信流程就容易很多了，Socket通信流程图如下：

![img](https://img-blog.csdnimg.cn/20191225154007754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9maWdodHN5ai5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

简单描述一下Socket的通信流程：

- 服务端首先创建一个Socket（Socket()），然后绑定IP地址和端口号（Bind()），之后注册监听（Listen()），这样服务端就可以监听指定的Socket地址了；
- 客户端这边也创建一个Socket（Socket()）并打开，然后根据服务器IP地址和端口号向服务器Socket发送连接请求（Connect()）；
- 服务器Socket监听到客户端Socket发来的连接请求之后，被动打开，并调用Accept()函数接收请求，这样客户端和服务器之间的连接就建立好了；
- 功建立连接之后，客户端和服务器就可以进行数据交互（Receive()、Send()）；
- 在数据交互完之后，就可以各自关闭连接（Close()），交互结束。



#### 75. **socket中read()和write()阻塞模式了解吗？**

当使用write()发数据，

- 首先会检查缓冲区，如果**缓冲区可用大小小于要发送数据的大小**，则会被阻塞，直到缓冲区中有足够空间，才会唤起write()；
- 如果**TCP协议正在向网络发送数据**，那么输出缓冲区将会被锁定；
- 如果发送数据大小大于缓冲区，那么数据将会被分批发送；
- 直到所有数据被发送完，write()函数才返回。

当使用read()接收数据，

- **一旦缓冲区有数据，就立刻被读取**，否则read()函数会被阻塞；**一旦缓冲区有数据，就立刻被读取**，否则read()函数会被阻塞；
- 如果要读取的数据长度**小于**缓冲区中的数据长度，那么就**不能**将缓冲区数据**全部读出**，剩余数据将不断积压，直到有read()函数再次读取；
- 直到读取到所有的数据之后，read()函数才会返回。

