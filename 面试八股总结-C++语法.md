## C/C++语言

#### 1. 在main执行之前和执行之后的代码可能是什么？

**main函数执行之前**，主要就是初始化系统相关资源：

- 设置栈指针（==操作系统开辟栈空间，因此要使用栈指针来访问==）
- 初始化静态static变量和global全局变量，即.data段的内容
- 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
- 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
- attribute__((constructor))



#### 2. 结构体的内存对齐问题？

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
- 未特殊说明时，按结构体中==size最大的成员对齐==（若有double成员，按8字节对齐）
-  **每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止**。
- 内存对齐的意义：因此假如没有内存对齐机制，数据任意存放，现在一个int变量，存放在地址1开始的连续的4个字节中，当处理器读取时，先从0位置一次读取4字节，提出前边不要的一个字节，再从位置4开始读取4字节块，剔除后边不要的3字节。这个过程很低效。

![1690185187971](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690185187971.png)

而有了内存对齐，int类型只能根据内存对齐规则存放在自身大小的倍数的位置，就可以一次读出：

![1690185446500](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690185446500.png)

下面是一个内存对齐的例子：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct {
    int i;
    char c1;
    char c2;
}x1;

struct {
    char c1;
    int i;
    char c2;
}x2;

struct {
    char c1;
    char c2;
    int i;
}x3;

int main() {
    cout << sizeof(x1)<< endl; // 输出8
    cout << sizeof(x2)<< endl; // 输出12
    cout << sizeof(x3)<< endl; // 输出8
    return 0;
}
```

具体结果可以参看下面的示意图：

![1690185683948](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690185683948.png)

#### 3. 指针和引用的区别

- 指针是一个变量，存储的是一个地址，引用是变量的别名，跟原变量是一个东西。
- 指针可以有多级，即可以定义指针的指针，而引用则不能。
- 指针可以为空，可以初始化为null，初始化后还可以改变指针的指向，而引用则必须在定义时初始化，一旦初始化绑定变量后，就不可再改变。
- 把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- ==引用的本质是一个指针常量（指针中的常量），指向不可改变==。



#### 4. 在传递函数参数，如何决定是使用指针还是引用？

- 需要返回函数内局部变量的内存的时候使用指针，指针传参需要开辟内存，用完需要释放指针，否则会内存泄露，而返回局部变量的引用是没有意义的。这是因为函数的局部变量在==函数栈==中开辟，函数结束之后，变量的内存自动释放，此时如果用引用去接的话，接的就是一个空指针，是不合法的。

- 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小。
- ==类对象==作为参数传递的时候使用引用，这是C++类对象传递的标准方式。



#### 5. 指针常量，常量指针和指向常量的指针？

首先说一下怎么快速的记住他们的区别，只需要**按照命名的顺序来读**，就可以很好地记忆，比如说：

```C++
int * const p = &a;
```

首先是一个指针`int *` ，然后一个`const`常量，那么p就是**指针常量**

```c++
const int *p= &a;
```

首先是一个`const`常量，然后一个指针`int *`，那么p就是**常量指针**



指针常量特点：**指针的指向不可以修改，指针指向的内存的值可以修改**。const限定的是指针p的值（执指向的地址），没有限制p指向的内存地址里的数据。

常量指针特点：**指针的指向可以修改，但是指针指向的值不可以修改。**

**指向常量的常指针**：

```c++
const int * const p = &a;
```

**特点： 指针的指向不可以修改，指针指向的值也不可以修改。**

```cpp
int a=10;
int * const p =&a;  //定义指针常量,指向int a的地址

*p = 20; //正确，指向的内存地址中的数据可以修改   
 
p=&b;  //错误，指向的内存地址不可以修改
```

```cpp
int a=10;
int b=10;
const int *p=&a;  //定义常量指针,指向int a的地址

*p = 20; //错误，指向的内存地址中的数据不可以修改   
 
p=&b;  //正确，指向的内存地址可以修改
```



#### 6. 指针所占内存

在**32位系统**中，处理器一次能处理的最大位数是2的32次方 ，也就是一次处理4个字节的内存数据，哪么指针的长度也就是4个字节。

在**64位系统**中，处理器一次能处理的最大位数是2的64次方 ，也就是一次处理8个字节的内存数据，哪么指针的长度也就是8个字节。

**32位系统指针4个字节，64位系统8个字节**

#### 7. 空指针和野指针

**空指针就是指向地址为空的指针**

**野指针是指针指向了一个随意的内存地址**，如果使用，会造成不可预知的内存错误。

[(44条消息) 【C/C++】 常量指针，指针常量、指向常量的常指针详解_c++常量指针_Z小旋的博客-CSDN博客](https://blog.csdn.net/as480133937/article/details/120804503)



#### 8. 堆和栈的区别

- 申请方式不同：堆区是自行申请和释放，栈区是系统分配和释放。
- 申请空间大小、排布、限制不同：栈区是一片连续的空间，大小由操作系统预定好，在Windows下是2M，空间较小，由高地址向低地址生长，如果申请空间大于剩余空间，分配失败，栈溢出。堆区在内存中是不连续的（系统使用链表存储空闲内存地址，自然是不连续的），堆大小受限于计算机系统中的有效虚拟内存（32位机理论上为4G），堆区较大。
- 申请效率不同：栈有系统自动分配，申请效率高，堆由开发者申请，效率低，且容易产生内存碎片。

**形象的比喻：**

栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



#### 9. 你觉得堆快一点还是栈快一点？

毫无疑问是栈快一点。

因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

#### 10. 区别以下指针类型？

```c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- int *p[10]表示指针数组，强调数组概念，**是一个数组变量**，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- int (*p)[10]表示数组指针，强调是指针，**只有一个变量**，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。



#### 11. new / delete 与 malloc / free的异同

**相同点**

- 都可用于内存的动态申请和释放

**不同点：**

- 前者是C++**运算符**，后者是C/C++语言**标准库函数**

- new自动计算要分配的空间大小，malloc需要手工计算

- new是类型安全的，malloc不是。例如：

  ```c++
  int *p = new float[2]; //编译错误
  int *p = (int*)malloc(2 * sizeof(double));//编译无错误
  ```

- 后者需要库文件支持，前者不用
- new是**封装了malloc**，直接free不会报错，但是这只是释放内存，而不会析构对象



#### 12. new和delete是如何实现的？

- new的实现过程是：首先调用名为**operator new**的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针。
- delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存。



#### 13. malloc和new的区别？

- malloc和free是标准库函数，支持**覆盖**；new和delete是运算符，支持**重载**。
- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会**调用构造函数和析构函数**。
- malloc和free返回的是**void类型指针**（**必须进行类型转换**），new和delete返回的是具体类型指针。
- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。



#### 14. 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？

在c语言中，malloc/free是用来负责动态申请/释放内存空间的，他们都是c中的库函数，而随着c++类和对象的出现，使得我们可以**自定义数据类型**，但是定义一个对象的时候会自动调用它的构造函数，在释放一个对象之前会自动调用它的析构函数，但是由于malloc和free都是库函数，都不在编译器的控制范围之内，编译器无法实现把执行构造函数和析构函数的任务强加给malloc和free，这就出现了new和delete了，new和delete的作用也是申请和释放内存空间，但是在执行new的时候会自动调用构造函数，执行delete的时候会调用析构函数。



#### 15. 被free回收的内存是立即返还给操作系统吗？

不是的，被free回收的内存会首先被**ptmalloc**使用**双链表**保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。



#### 16. 宏定义和函数有何区别？

- 宏在**预处理阶段**完成替换，之后被替换的文本参与编译，相当于**直接插入了代码**，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏定义参数没有类型，**不进行类型检查**；函数参数具有类型，需要检查类型。
- 宏定义不要在最后加分号。



#### 17. 宏定义和typedef区别？

- 宏主要用于定义**常量**及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在**编译阶段之前**（预处理阶段），属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

下面举例说明二者的区别：

首先需要知道 `int* a, b`是什么意思，这里表示定义了两个变量，·a是`int*`类型的指针，b是`int`类型的变量。而`int *a, *b`则表示a, b都是指针，明确了这一点，我们继续看：

```c++
#include <iostream>
using namespace std;

#define R1 int*
typedef int* R2;

int main() {
    R1 a, b;		// define
    R2 c, d;		// typedef

    cout << sizeof(a) << endl;
    cout << sizeof(b) << endl;
    cout << sizeof(c) << endl;
    cout << sizeof(d) << endl;

    return 0;
}
```

结果如下：

![1690201620267](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690201620267.png)

可以看到，宏仅仅是替换内容，等效于`int* a, b`，而typedef才是真正定义了`int*` 的别名。



#### 18. 变量声明和定义区别？

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。（声明可以有多个，但是定义只能有一个）



#### 19.  strlen和sizeof区别？

- sizeof是运算符，并不是函数，结果在**编译时**得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是**任何数据的类型或者数据**（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
- 因为sizeof值在编译时确定，所以**不能用来得到动态分配**（运行时分配）存储空间的大小。



#### 20. C++从代码到可执行程序经历了什么？

1. **编译期**

   编译期主要是编译器的**预处理**和**编译C++代码**：

   预处理阶段：宏替换 #define，条件编译 #ifndef #endif，头文件，保留所有的#pragma 编译器指令，处理“#include”预编译指令，删除所有的注释......

   编译阶段：把预编译生成的xxx.i或xxx.ii文件，进行一系列词法分析，语法分析，语义分析及优化后，生成相应的汇编代码
   文件。

   汇编过程：将汇编代码变成机器可以执行的指令（机器码文件），汇编过程产生目标文件（Linux：xxx.o，Window：xxx.obj）

   链接：将不同源文件产生的目标文件进行链接，从而形成一个可以执行的程序，链接分为静态链接和动态链接。

2.  **运行期**

   动态内存分配（new/malloc)，运行程序



#### 21. 静态链接和动态链接的概念与区别？

- 静态链接：将所有程序模块都链接为一个单独的可执行文件
- 动态链接：把程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起，形成一个完整的程序。

静态链接以及具备所有程序执行所需要的东西，执行时速度更快，但是因为每个可执行程序对所需的目标文件都有一份副本，所以如果多个程序依赖同一个目标文件，就存在多个目标文件的副本，造成空间浪费；此外，因为整个程序都已经编译完成，后续如果要修改更新，就需要全部重新编译执行，造成更新困难，使用动态链接则解决了这个问题。但同时动态链接的缺点就是性能损耗，这是由于把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。



#### 22. C++和C语言的区别

- C++是面向对象的语言，C是面向过程的语言，C++具有面向对象的三大特性，即继承、封装和多态。
- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。这也是c++多态的体现。
- C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
- 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
- C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库
- 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等。



#### 23. C++与Java的区别

**语言特性**

- Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强。
- Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。
- C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果。
- Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性。

**语言特性**

- C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放。
- Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。

**应用场景**

- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）
- Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架。
- 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在。



#### 24. C++中struct和class的区别

**相同点**

- 两者都拥有成员函数、公有和私有部分
- 任何可以使用class完成的工作，同样可以使用struct完成

**不同点**

- 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
- class默认是private继承， 而struct默认是public继承



#### 25. public，protected和private访问和继承权限/public/protected/private的区别？

- public的变量和函数在类的**内部外部**都可以访问。
- protected的变量和函数只能在类的内部和其**派生类**中访问。
- private修饰的元素只能在**类内**访问。

（一）访问权限

派生类可以继承基类中**除了构造/析构**、**赋值运算符重载函数**之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在**通过派生类的对象**对基类成员的访问。

![img](http://oss.interviewguide.cn/img/202205212341241.png)

派生类对基类成员的访问形象有如下两种：

- **内部访问**：由派生类中新增的成员函数对从基类继承来的成员的访问
- **外部访问**：在派生类外部，通过派生类的对象对从基类继承来的成员的访问

（二）继承权限

**public继承**

公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问。

**protected继承**

保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下表：

![img](http://oss.interviewguide.cn/img/202205212341074.png)

**private继承**

私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表

![img](http://oss.interviewguide.cn/img/202205212341430.png)

**总结**

一、访问权限

| 访问权限  | 外部 | 派生类 | 内部 |
| :-------: | :--: | :----: | :--: |
|  public   |  ✔   |   ✔    |  ✔   |
| protected |  ❌   |   ✔    |  ✔   |
|  private  |  ❌   |   ❌    |  ✔   |

public、protected、private 的访问权限范围关系：public > protected > private

二、继承权限

1. 派生类继承自基类的成员权限有四种状态：public、protected、private、不可见。
2. 派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限。
3. 派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了 private 的继承方式遇到 private 成员是不可见外）。



#### 26. define宏定义和const的区别

- 编译阶段上：

  define是在编译的**预处理阶段**起作用，而const是在**编译、运行**时候起作用。

- 安全性上：

  define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加一个大括号包住全部的宏定义内容，不然容易出错，而const是常量是有数据类型的，编译器可以对它进行安全检查。

- 内存占用上：

  define只是将宏名称进行替换，在内存中会产生多份相同的备份，const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表，define占用代码段空间，const占用数据段空间

- const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；define独特功能，比如可以用来防止文件重复引用。


#### 27. C++中const和static的作用



#### 28. C++的顶层const和底层const



#### 29. 数组名和指针（这里为指向数组首元素的指针）区别？

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- **当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。**

```cpp
void traverse(int *a) {
    cout << sizeof(a) << endl;              // sizeof运算符不能再得到原数组的大小了，此时就是8
    cout << *(++a) << endl;                 // 退化成一般指针，可以自增了
}

int main() {
    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
    int *p = arr;
    for (int i = 0; i < 10; ++i) {
        cout << *(arr + i) << endl;         // 都可以通过偏移量来访问数组中的元素
        cout << *(p + i) << endl;
    }

    cout << sizeof(arr) << endl;            // 数组的大小：40 = 4(int) * 10
    cout << sizeof(p) << endl;              // 指针的大小：8

    //cout << *(++arr) << endl;             // 错误，不能自增
    cout << *(++p) << endl;                 // 可以自增，结果为2

    traverse(arr);  

    return 0;
}
```



#### 30. final和override关键字

**override**

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：

```cpp
class A {
    virtual void foo();
};

class B : public A {
    void foo(); //OK
    virtual void foo(); // OK
    void foo() override; //OK
};

```

如果不使用override，当你手一抖，将**foo()**写成了**f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，**它指定了子类的这个虚函数是重写的父类的**，如果你名字不小心打错了的话，编译器是不会编译通过的。

```cpp
class A {
    virtual void foo();
};

class B : public A {
    virtual void f00(); //OK，这个函数是B新增的，不是继承的
    virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错
};
```

**final**

当不希望**某个类被继承**，或不希望**某个虚函数被重写**，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：

```cpp
class Base
{
    virtual void foo();
};
 
class A : public Base
{
    void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写
};

class B final : A // 指明B是不可以被继承的
{
    void foo() override; // Error: 在A中已经被final了
};
 
class C : B // Error: B is final
{
};

```

补充：普通的函数能不能使用final关键字呢？

不能。编译器会报错：不能使用**"final"**修饰符声明非虚函数。



#### ==31. C++的虚特性virtual（虚基类，虚继承，虚函数，纯虚函数，抽象类）==



#### 32. 拷贝初始化和直接初始化

- 对于简单类型来说，初始化和赋值没什么区别
- 对于类和复杂数据类型来说，这两者的区别就大了，举例如下：

```cpp
class A{
public:
    int num1;
    int num2;
public:
    A(int a=0, int b=0):num1(a),num2(b){};
    A(const A& a){};
    //重载 = 号操作符函数
    A& operator=(const A& a){
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main(){
    A a(1,1);
    A a1 = a; //拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
    return 0;
}
```



#### 33. extern"C"的用法

为了能够**正确的在C++代码中调用C语言**的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；

哪些情况下使用extern "C"：

1. C++代码中调用C语言代码；
2. 在C++中的头文件中使用；
3. 在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

举个例子，C++中调用C代码：

```cpp
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__

extern "C"{
    typedef unsigned int result_t;
    typedef void* my_handle_t;
    
    my_handle_t create_handle(const char* name);
    result_t operate_on_handle(my_handle_t handle);
    void close_handle(my_handle_t handle);
}
```

综上，总结出使用方法**，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。**所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。



#### 34. 野指针和悬空指针

都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

- 野指针

  野指针，指的是没有被初始化过的指针

  ```cpp
  int main(void) { 
      
      int* p;     // 未初始化
      std::cout<< *p << std::endl; // 未初始化就被使用
      
      return 0;
  }
  ```

  

- 悬空指针

  悬空指针，指针最初指向的内存已经被释放了的一种指针。

```cpp
int main(void) { 
  int * p = nullptr;
  int* p2 = new int;
  
  p = p2;

  delete p2;
}
```

此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。 避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。

**产生原因及解决办法：**

野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空



#### 35. C和C++的类型安全



#### 36. C++中的重载、重写（覆盖）和隐藏的区别

**（1）重载（overload）**

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是**函数名相同**，**参数类型和数目有所不同**，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：

```cpp
class A{
    ...
    virtual int fun();
    void fun(int);
    void fun(double, double);
    static int fun(char);
    ...
}
```

**（2）重写（覆盖）（override）**

重写指的是在派生类中覆盖基类中的同名函数，**重写就是重写函数体**，**要求基类函数必须是虚函数**且：

- 与基类的虚函数有相同的参数个数
- 与基类的虚函数有相同的参数类型
- 与基类的虚函数有相同的返回值类型

举个例子：

```cpp
//父类
class A{
public:
    virtual int fun(int a){}
}
//子类
class B : public A{
public:
    //重写,一般加override可以确保是重写父类的函数
    virtual int fun(int a) override{}
}
```

重载与重写的区别：

- 重写是父类和子类之间的**垂直关系**，重载是不同函数之间的**水平关系**
- 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
- 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

**（3）隐藏（hide）**

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：

- 两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**

- **两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。**

下面辨析一下一下第一种情况的隐藏和重写的区别：首先是重写

```cpp
//父类
class A {
public:
     virtual void fun() {
        cout << "A中的fun函数" << endl;
    }
};

//子类
class B : public A {
public:
    void fun() override {
        cout << "B中的fun函数" << endl;
    }
};

int main() {
    B b;
    b.fun();    // 调用的是B中的fun函数
    A& a = b;
    a.fun();    // 调用的仍然是B中的fun函数
    A* c = &b;
    c->fun();   // 调用的仍然是B中的fun函数
    return 0;
}
```

下面是隐藏：

```cpp
//父类
class A {
public:
     void fun() {
        cout << "A中的fun函数" << endl;
    }
};

//子类
class B : public A {
public:
    //隐藏父类的fun函数
    void fun() {
        cout << "B中的fun函数" << endl;
    }

    void fun2() {
        cout << "here" << endl;
    }
};

int main() {
    B b;
    b.fun();    // 调用的是B中的fun函数
    A& a = b;
    a.fun();    // 此时调用是A中的fun函数
    A* c = &b;
    c->fun();   // 此时调用是A中的fun函数
    return 0;
}
```

可以看到，重写和隐藏的时候，使用父类引用或指针定义变量时，如果使用子类来进行初始化，**重写仍然是调用子类的成员函数**，而**隐藏则是调用父类的成员函数**。



#### 37. C++有哪几种的构造函数

C++中的构造函数可以分为5类：**默认构造函数、初始化构造函数（有参构造函数）、拷贝构造函数、转换构造函数、移动构造函数**。

**默认构造函数：**

未提供显式初始值时，用来创建对象的构造函数。以Student类为例，默认构造函数的原型为：

```cpp
Student();//没有参数
Student(int num=0;int age=0);//所有参数均有默认值
```

**初始化构造函数：**

有参数和参数列表

```cpp
Student(int num，int age）;//有参数
```

**拷贝构造函数：**

```cpp
Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
    this->age = s.age;
    this->num = s.num;
}; 
```

**转换构造函数：**

转换构造函数用于将其他类型的变量，隐式转换为本类对象。

**移动构造函数：**

拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，可以省去很多拷贝负担，通常和右值引用配合。



#### 38. 深拷贝和浅拷贝的区别

**浅拷贝**

浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

**深拷贝**

深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

```cpp
// A类的拷贝构造函数是浅拷贝，B类的拷贝构造函数是深拷贝

class A{
public:
    A() {};

    A(int size) : size_t(size) {
        data_t = new int[size];
    }

    A(const A& a) {
        size_t = a.size_t;  // 浅拷贝
        data_t = a.data_t;
    }

    ~A() {
        delete[] data_t;  // 注意使用的应该是delete[]
    }

    int *data_t;
    int size_t;
};

class B{
public:
    B() {};

    B(int size) : size_t(size) {
        data_t = new int[size];
    }

    B(const B& a) {
        size_t = a.size_t;  // 深拷贝
        data_t = new int[size_t];
    }

    ~B() {
        delete[] data_t;  // 注意使用的应该是delete[]
    }

    int *data_t;
    int size_t;
};

int main() {
    A a(10);
    A b = a;

    cout << a.data_t << endl;
    cout << b.data_t << endl;
    
    B c(10);
    B d = c;

    cout << c.data_t << endl;
    cout << d.data_t << endl;
}
```

运行结果：





#### 39. 内联函数和宏定义的区别

C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：

```cpp
inline int max(int a, int b)
{
    return a > b ? a : b;
}
```

则调用： `cout << max(a, b) << endl;`

在编译时展开为： `cout << (a > b ? a : b) << endl;`  从而消除了把 max写成函数的额外执行开销。

下面是内联函数和宏定义的区别：

- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。

- 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
- 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义。
- 内联函数有类型检测、语法判断等功能，而宏没有。
- 宏不可调试。
- 宏无法操作类的私有对象。

下面举例说明宏容易产生歧义并且容易出错的情况：

![1690443264046](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690443264046.png)

注意：**关键字 inline 必须与函数定义体放在一起才能使函数成为内联**，仅将 inline 放在函数声明前面不起任何作用。C++ inline函数是一种“**用于实现的关键字**”，而不是一种“用于声明的关键字”

此外，定义在类声明之中的成员函数将自动地成为内联函数，例如：

```cpp
class A
{  
public:
    void Foo(int x, int y) { ... }   // 自动地成为内联函数  
} 
```



内联函数应该在**头文件中定义**，这一点不同于其他函数。当然也可以在源文件中定义，但此时只有定义的那个源文件可以用它。也就是说，如果多个源文件都要使用某个类的内联函数的话，需要在每个源文件中重复定义。但是如果定义在头文件中，编译器就帮我们把这个重复的过程做了。

也就是说：**内联函数是可以在不同的源文件中重复定义的，不会产生链接错误**。

==慎用内联函数：==

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率，如果函数太长，反而会降低效率。

**Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数。**

**Tip： 复杂的内联函数的定义, 应放在后缀名为 -inl.h 的头文件中。**

参考：[C++内联函数的使用 - 余生以学 - 博客园 (cnblogs.com)](https://www.cnblogs.com/2018shawn/p/10851779.html)



#### 40. 如何用代码判断大小端存储？

大端存储：字数据的高字节存储在低地址中（文件传输，网络传输中常使用）

小端存储：字数据的低字节存储在低地址中（现代cpu的处理方式，按照顺序，从低字节开始处理）

**所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输**

小端模式中的存储方式为：

![img](http://oss.interviewguide.cn/img/202205071832785.png)

大端模式中的存储方式为：

![img](http://oss.interviewguide.cn/img/202205071832707.png)

**方式一：使用强制类型转换**-这种法子不错

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    // 由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

**方式二：巧用union联合体**

```cpp
#include <iostream>
using namespace std;
//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
union endian
{
    int a;
    char ch;
};
int main()
{
    endian value;
    value.a = 0x1234;
    //a和ch共用4字节的内存空间
    if (value.ch == 0x12)
        cout << "big endian"<<endl;
    else if (value.ch == 0x34)
        cout << "little endian"<<endl;
}
```



#### 41. volatile、mutable和explicit关键字的用法

**（1）volatile**

volatile 关键字是一种类型修饰符，**==用它声明的类型变量表示可以被某些编译器未知的因素更改==**，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

当要求使用 volatile 声明的变量的值的时候，**系统总是==重新==从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。

**volatile定义变量的值是==易变==的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。**

**多线程下的volatile**

有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，**该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。**如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。

volatile的意思是让编译器每次操作该变量时一定要==从内存中真正取出==，而不是使用已经存在寄存器中的值。

**（2）mutable**

mutable的中文意思是**“可变的，易变的”**，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。一般而言，使用const修饰的函数不能更改成员变量，比如get函数，但是有时候我们需要在const函数里面修改一些成员函数，就可以使用multable关键字。

**例一**

```cpp
class person
{
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
public:
    void add() const//在函数里不可修改this指针指向的值 常量指针
    {
        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针
        m_B = 20;//正确
    }
};
```

**例二**

```cpp
class person
{
public:
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
};

int main()
{
    const person p = person();//修饰常对象 不可修改类成员的值
    p.m_A = 10;//错误，被修饰了指针常量
    p.m_B = 200;//正确，特殊变量，修饰了mutable
}
```

**（3）explicit**

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以**显式的方式进行类型转换**，注意以下几点：

- explicit 关键字只能用于**类内部的构造函数声明上**
- 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换（**避免未知情况出现**）



#### 42. ==什么时候会调用拷贝构造函数(老生常谈)==

- 用类的一个实例化对象去初始化另一个对象的时候
- 函数的参数是类的对象时（非引用传递）
- 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数（这一点与编译器有关）

**总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在==值返回的情况下发生拷贝构造函数==，==引用返回方式则不发生拷贝构造函数==**。

下面通过例子说明：

```cpp
#include <iostream>
using namespace std;

class Person {
public:
    Person() {};
    Person(int age, string name) : age(age), name(name) {};
    Person(const Person& p) {
        this->age = p.age;
        this->name = p.name;
        cout << "调用拷贝构造函数" << endl;
    }
    
    int age = 0;
    string name = " ";
};

void func(Person p) {
    cout << p.age << endl;
    cout << p.name << endl;
}

Person createObject() {
    Person p;
    return p;                   // 以值的方式返回局部对象，VS2022并不会对值返回局部变量的方式调用拷贝构造函数，已经优化了
}

int main() {
    Person p1;
    p1.name = "小王";
    p1.age = 100;           
    Person p2(p1);              // 调用拷贝构造函数
    func(p1);                   // 调用拷贝构造函数
    createObject();

    system("pause");
    return 0;
}
```

经过测试，在VS2022并不会对值返回局部变量的方式调用拷贝构造函数，已经优化了（**返回值优化**）

在Linux+ g++环境中也不会调用拷贝构造函数。



#### 43. C++中有几种类型的new

在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new

（1）**plain new**

言下之意就是普通的new，就是我们常用的new，在C++中定义如下：

```cpp
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的。

比如说分配一个超级大的内存：

```cpp
int* arr = new int[10000000000000000];
```

![1690701427010](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690701427010.png)

会报错std::bad_alloc。

（2）**nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：

```cpp
void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

调用的语法如下：

```cpp
int* arr(nothrow) = new int[10000000000000000];
```

（3）**placement new**

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是**调用对象的构造函数**。定义如下：

```cpp
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

- palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
- placement new构造起来的对象数组，要**==显式的调用他们的析构函数来销毁==**（析构函数并不释放对象的内存），**==千万不要使用delete==**，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。(注意上述的两点)

```cpp
#include <iostream>
#include <string>
using namespace std;
class ADT {
	int i;
	int j;
public:
	ADT() {
		i = 10;
		j = 100;
		cout << "ADT construct i=" << i << ", " << "j=" << j << endl;
	}
	~ADT() {
		cout << "ADT destruct" << endl;
	}
};
int main()
{
	char* p = new(nothrow) char[sizeof ADT + 1];
	if (p == NULL) {
		cout << "alloc failed" << endl;
		exit(-1);
	}
	ADT* q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
	//delete q;//错误!不能在此处调用delete q;
	q->ADT::~ADT();//显示调用析构函数
	delete[] p;
	return 0;
}

// 输出
// ADT construct i=10, j=100
// ADT destruct
```



#### 44. C++的异常处理的方法

在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：

- 数组下标越界
- 除法计算时除数为0
- 动态分配空间时空间不足
- 空指针野指针的隐患

**（1）try、throw和catch关键字**

**throw 语句**

语法如下：`throw 表达式;`
该语句拋出一个异常。异常可以是一个表达式，其值的类型可以是基本类型，也可以是类。

**try…catch 语句**

```cpp
try {
    try块
}
catch(异常类型) {
    “catch块”
}
...
catch(异常类型) {
    “catch块”
}
```

catch 可以有多个，但至少要有一个。

**try…catch 语句的执行过程是：**

- 执行 try 块中的语句，如果执行的过程中没有异常拋出（执行throw语句即为**抛出**），那么执行完后就执行最后一个 catch 块后面的语句（即**跳过所有catch**），所有 catch 块中的语句都不会被执行；
- 如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。

不论拋出哪种类型的异常都能捕获，可以编写如下 catch 块：（不推荐使用）

```cpp
catch(...) {
    ...
}
```

```cpp
#include <iostream>
using namespace std;
int main()
{
    double m, n;
    cin >> m >> n;
    try {
        cout << "before dividing." << endl;
        if (n == 0)
            throw - 1;  //抛出整型异常
        else if (m == 0)
            throw - 1.0;  //拋出 double 型异常
        else
            cout << m / n << endl;
        cout << "after dividing." << endl;
    }
    catch (int d) {
        cout << "catch (int)" << d << endl;
    }
    catch (double d) {
        cout << "catch (double)" << d << endl;
    }
    // 不推荐使用这种万金油的写法
    //catch (...) {
    //    cout << "catch (...)" << endl;
    //}
    cout << "finished" << endl;
    return 0;
}
```

**（2）函数的异常声明列表**

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数**声明和定义**时，指出所能抛出异常的列表，写法如下：

```cpp
int fun() throw(int,double,A,B,C){...};
```

```cpp
#include <iostream>
#include <string>

using namespace std;

int func(int i, int j) throw(int, char) {
    if ((0 < j) && (j < 10)) {
        return (i + j);
    }
    else {
        throw '0';
    }
}

void test(int i) try {
    cout << "func(i, i) = " << func(i, i) << endl;
}
catch (int j) {
    cout << "Exception: int : " << j << endl;
}
catch (char j) {
    cout << "Exception: char : " << j << endl;
}

int main(int argc, char* argv[]) {
    test(5);
    test(10);
    return 0;
}
```

**（3）C++标准异常类 exception**

C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示：

![img](http://oss.interviewguide.cn/img/202205212342667.png)

- bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常。
- bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常。
- bad_alloc：在用 new 运算符进行动态内存分配时，**如果没有足够的内存，则会引发此异常**。
- out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常。

```cpp
#include <iostream>
#include <vector>

using namespace std;
int main()
{
    vector<int> v(10);
    try {
        v.at(100) = 100;  //拋出 out_of_range 异常，相当于这里的out_of_range就是一个类
    }
    catch (out_of_range& e) {
        cout << e.what() << endl;
    }
    string s = "hello";
    try {
        char c = s.at(100);  //拋出 out_of_range 异常
    }
    catch (out_of_range& e) {
        cout << e.what() << endl;
    }
    return 0;
}
```



#### 45. static的用法和作用？

**1. 隐藏**（最重要的一条）

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，通过下面的例子我们可以看到：

```cpp
// a.cpp
char global = 'h';
void global_func() {
    cout << "hello" << endl;
}

// b.cpp
void global_func();		// 声明
int main()
{
    extern char global;			 // 外部声明，表明变量声明在外面
    cout << global << endl; 
    global_func();
    return 0;
}
```

如果没有用static修饰变量，那么其他的文件可以见到自己文件中的全局变量。如果加了static，就会对其它源文件隐藏。例如在global和global_func的定义前加上static，b.cpp就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。

**2. 初始化一次**

只能初始化一次，但是可以有多次赋值，且默认初始化为0，在mian函数之前预编译阶段分配好了内存，只能在类外初始化。存放的位置为**静态区**。c++中共有两种变量存在静态区：全局变量和static变量，不过static可以控制变量的可见范围。

**3. 存在时间长**

存储在静态数据区，作用时间为程序时间。

**4. C++中类成员声明为static**

- 作用范围内的static成员变量可以被作用范围内所有函数访问，不能被作用范围外其他函数访问；
- 类中static的成员变量属于整个类，每个对象共享该static，对类的所有对象只有一份拷贝；
- static成员函数没有this指针，只能访问**类内的static成员变量**，不能访问非static的类成员；
- 只能在**类外初始化**，因为static先于主函数创建存在，只能在类外初始化；
- static成员不属于任何对象或者实例，不能被virtual修饰，static成员函数没有this指针，不能与const连用。



#### 46. 形参与实参的区别？

**1. 作用域**

形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。

**2. 实参预先确定**

实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。

**3. 严格匹配**

实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。

**4. 单向**

数调用中发生的数据传送是**单向的**。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。

**5. 独立**

当形参和实参**不是指针或引用**类型时，在该函数运行时，形参和实参是不同的变量，他们在**内存中位于不同的位置**，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。



#### 47. 值传递、指针传递、引用传递的区别和效率

1. 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）
2. 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
3. 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
4. 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。



#### 48. const关键字的作用有哪些?

1. 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；（定义常量就用const）
2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；、
4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；
5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”；
6. const类型变量必须定义的时候进行初始化，因此也导致==如果类的成员变量有const类型的变量==，==那么该变量必须在类的初始化列表中进行初始化==；（非常重要）



#### 49. 类的继承

所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；

子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，==子类对象可以当做父类对象使用==。

```cpp
Person p = new Student();	// 其中Person是基类，Student是派生类，这样的语法是ok的
```



#### 50. delete p、delete [] p、allocator都有什么作用？

delete p会调用一次析构函数，而delete[] p会调用每个成员的析构函数。看下面的代码：

```cpp
int main()
{
    // 对于自定义类
    A* a1 = new A();
    delete a1;              // 调用一次析构函数
    //delete[] a1;            // 编译器不会报错，但是系统会一直调用析构函数（无限循环）

    A* a2 = new A[10];
    delete[] a2;            // 调用10次析构函数
    //delete a2;              // 会出错，因为只析构了一次，出现了内存泄露

    // 普通数据类型
    int* p1 = new int[10];
    delete[] p1;
    //delete p1;                // 不会出错，普通数据类型没有析构函数

    int* p2 = new int;
    delete p2;
    //delete[] p2;              // 不会出错

    return 0;
}
```

 由上面的代码可以看出，delete[] p和delete p的区别在于他们对于非内部数据对象处理上，如果数组类型是自定义类，那么new[]只能用delete[]来对应，new和delete对应，但是对于普通数据类型而言，他们作用的效果是一样的，例如`int* p=new int[10]`,`delete p和delete[] p`作用效果是一样的，原因是**==内部普通数据类型没有析构函数==**。
**下面看一个题目：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190826215732986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzgxNTcz,size_16,color_FFFFFF,t_70)

`allocator`：是C++标准库中的一个模板类，用于动态分配和释放内存，它提供了一种更高级、更安全的方式来管理内存。使用`allocator`可以避免直接使用`new`和`delete`，从而减少内存泄漏和内存错误的风险。`allocator`可以用于分配单个对象或数组。

```c++
allocator<int> myAllocator;
int* p = myAllocator.allocate(5); // 分配内存，存放 5 个 int 元素的数组

for (int i = 0; i < 5; i++) {
    p[i] = i + 1; // 设置数组元素的值
}

for (int i = 0; i < 5; i++) {
    cout << p[i] << " "; // 输出数组元素的值
}

myAllocator.deallocate(p, 5); // 释放内存
```



#### 51. malloc申请的存储空间能用delete释放吗?

不能，malloc/free主要为了兼容C，new和delete 完全可以取代malloc /free的。

malloc/free的操作对象都是必须明确大小的，而且不能用在动态类上。

new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。



#### 52. 类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？

**1. 类成员初始化方式**

赋值初始化：通过在函数体内进行赋值初始化；列表初始化，在冒号后面使用初始化列表进行初始化。

**对于第一种：**

是在所有数据成员被分配内存后才进行的。

**对于第二种：**

列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么分配了内存空间后再进入函数体之前给数据成员赋值，就是说**初始化这个数据成员此时函数体还未执行**。==类中的const成员只能且必须在初始化列表初始化==。初始化列表在构造函数执行前执行。

**2. 一个派生类的构造函数的执行顺序**

1. 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
2. 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
3. **类类型的成员对象**的构造函数（按照成员对象在类中的定义顺序）。
4. 派生类自己的构造函数。

**3. 为什么用成员初始化列表会快一些**

首先把数据成员按类型分类

1. 内置数据类型，复合类型（指针，引用）
2. 用户定义类型（类类型）

分情况说明：

- 对于类型1，在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的
- 对于类型2，结果上相同，但是在性能上会存在差别

由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但**如果有些成员是类**，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作（对象已存在），所以**如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。**



#### 53. 有哪些情况必须要用到成员列表初始化？

**必须使用成员初始化列表的四种情况：**

1. 当初始化一个引用成员时；
2. 当初始化一个常量成员时；
3. 当调用一个基类的构造函数，而它拥有一组参数时（就是说没有默认构造函数）；
4. 当调用一个成员类的构造函数，而它拥有一组参数时（就是说没有默认构造函数）；

这是因为如果只有有参的构造函数，就会自动屏蔽无参构造函数，如果使用普通的初始化方式，需要先调用基类或者成员类的默认构造函数，此时是找不到的，但是使用初始化列表的话，是直接调用拷贝构造函数，不会被屏蔽。



#### 54. C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？

string继承自basic_string,其实是对char* 进行了封装，封装的string包含了char*数组，容量，长度等等属性。

string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。

如果让你**手写实现string类**，怎么说，这里也复习一波。

**题目：实现string类**

包含构造函数、拷贝构造函数、析构函数、拷贝赋值

扩展：重载+、重载+=、重载==、重载[]、重载<<

```cpp
#MyString.h
#pragma once
#include <string>
#include <iostream>

using namespace std;
class MyString {
public:
	MyString(const char* str = 0);				// 构造
	MyString(const MyString& str);				// 拷贝构造
	MyString& operator=(const MyString& str);	// 重载=
	MyString operator+(const MyString& str);	// 重载+
	MyString& operator+=(const MyString& str);	// 重载+=
	bool operator==(const MyString& str) const;	// 重载==
	char& operator[](int index);				// 重载[]

	~MyString();								//  析构
	friend ostream& operator<<(ostream& os, const MyString& str);  // 输出

private:
	char* m_data;
};
```

```cpp
#MyString.cpp
#include "myString.h"

MyString::MyString(const char* pstr) {
	if (pstr) {
		m_data = new char[strlen(pstr) + 1];
		strcpy(m_data, pstr);
	}
	else {
		m_data = new char[1];
		*m_data = '\0';
	}
}


MyString::MyString(const MyString& str) {
	m_data = new char[sizeof(str.m_data) + 1];
	strcpy(m_data, str.m_data);
}

MyString& MyString::operator=(const MyString& str) {
	if (this == &str) return *this;
	delete[] m_data;
	m_data = new char[strlen(str.m_data) + 1];
	strcpy(m_data, str.m_data);
	return *this;
}

// 注意不能加&，不能返回本地变量的地址（一般不推荐这么做，产生莫名的bug）
MyString MyString::operator+(const MyString& str) {
	// 新建一个长度为自身+连接字符的字符串，主段拷贝
	MyString newString;
	newString.m_data = new char[strlen(m_data) + strlen(str.m_data) + 1];
	strcpy(newString.m_data, m_data);
	strcat(newString.m_data, str.m_data);
	return newString;
}

// +=在原来字符串实现，所以新建char *，全部拷贝过去，再把m_data指向
MyString& MyString::operator+=(const MyString& str) {
	char *newData = new char[strlen(m_data) + strlen(str.m_data) + 1];
	strcpy(newData, m_data);
	strcat(newData, str.m_data);
	delete[] m_data;
	m_data = newData;
	return *this;
}


bool MyString::operator==(const MyString& str) const {
	if (strlen(m_data) != strlen(str.m_data)) {
		return false;
	}
	return strcmp(m_data, str.m_data) ? false : true;
}


char& MyString::operator[](int index) {
	if (index > strlen(m_data)) {
		throw "invalid index";
	}
	else {
		return m_data[index];
	}
}

MyString::~MyString() {
	delete[] m_data;
	m_data = nullptr;
}

ostream& operator<<(ostream& os, const MyString& str)//输出
{
	os << str.m_data << endl;
	return os;
}
```

注意：为了能实现链式编程，重载运算符一般都使用引用的方式返回，但是有一点，==**局部变量（临时变量）千万不要用引用的方式返回，会出现未知bug**==。



#### 55. 什么是内存泄露，如何避免？如何检查和定位？

**内存泄露**

一般我们常说的内存泄漏是指**堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定）内存块，使用完后必须**==显式释放==**的内存。应用程序般使用malloc、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

**避免内存泄露的几种方式**

- 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露；
- 一定要将基类的析构函数声明为**虚函数**；
- 对象数组的释放一定要用**delete []**;
- 有new就有delete，有malloc就有free，保证它们一定成对出现；
- 使用智能指针。

**检查、定位内存泄漏**

检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出：

输出这样的格式{453}normal block at 0x02432CA8,868 bytes long

被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。

定位代码位置

在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include <crtdbg.h>



#### 56. 对象复用的了解，零拷贝的了解

**对象复用**

对象复用其本质是一种设计模式：Flyweight享元模式。

通过将对象存储到"对象池"中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。

**零拷贝**

零拷贝就是一种**避免 CPU 将数据从一块存储拷贝到另外一块存储的技术**，可以减少数据拷贝和共享总线操作的次数。在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：**使用push_back()函数需要调用==拷贝构造函数和转移构造函数==，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。



#### 57. 介绍面向对象的三大特性，并且举例说明

三大特性：继承、封装和多态

**（1）继承**

**让某种类型对象获得另一个类型对象的属性和方法。**

它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

**（2）封装**

也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

**（3）多态**

多态是指用相同的**接口**去表示不同的**实现**。在c++中，多态**允许将子类类型的指针赋值给父类类型的指针**。

实现多态有二种方式：重写（override），重载（overload）。

重写是指子类重新定义父类的虚函数，注意一定要是虚函数。

重载则是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。



#### 58. C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast



#### 59. C++函数调用的压栈过程

函数的调用过程：

1. 从栈空间分配存储空间
2. 从实参的存储空间复制值到形参栈空间
3. 进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。



#### 60. 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？



#### 61. 说说移动构造函数

1. 我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
2. 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。

所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；

3. 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个**右值引用**。意味着，移动构造函数的参数是一个**右值**或者**将亡值**的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。



#### 62. C++中将临时变量作为返回值时的处理过程

首先注意，临时变量是不能做使用引用返回的，C++中最好不要这样做。

首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，**当函数退出时，临时变量出栈，即临时变量已经被销毁**，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了。

C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit。

由此可见，函数调用结束后，返回值被临时存储到**==寄存器==**中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。



#### 63. 如何获得结构成员相对于结构开头的字节偏移量

注意，这里涉及到内存对齐的知识，一般会按照**最大成员变量进行内存对齐**，也跟结构体中定义的位置有关。

使用<stddef.h>头文件中的，offsetof宏。

举个例子：

```cpp
#include <iostream>
#include <stddef.h>
using namespace std;

struct  S
{
	int x;
	char y;
	int z;
	double a;
};
int main()
{
	cout << offsetof(S, x) << endl; // 0
	cout << offsetof(S, y) << endl; // 4
	cout << offsetof(S, z) << endl; // 8
	cout << offsetof(S, a) << endl; // 16
	return 0;
}
```

在Visual Studio 2022 + Win11 下的输出情况如上

具体的分析如下，首先成员中最长的就是double，为8个字节，所以内存对齐都要按照8个字节来对齐，具体的示意图如下：

![1690858949069](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690858949069.png)



#### 64. 静态类型和动态类型，静态绑定和动态绑定的介绍（多态中的体现）

- 静态类型：对象在声明时采用的类型，在编译期既已确定；
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

简单的说：==**动态类型是可以发生变化的；并且动态类型的概念是针对指针和引用这两个东西而引出来的**==。

```cpp
class Base
{

};
class Derived:public Base
{

};
class SubDerived:public Derived
{

};
int main()
{


Base* pb = new Derived; //pb的静态类型为Base*，我们不用运行就知道了，编译时候就能够确定下来；
						//pb的动态类型为 Derived*，这个只有在运行阶段才可以确定下来，
						//即程序运行到这句代码，才可以直到pb的动态类型为 Derived*
						
Derived der; //派生类对象，派生类的对象der的静态类型为derived,动态类型：无；
Base& pc = der; //pc的静态类型为 base,动态类型为 derived;

pb = new SubDerived; //pb的静态类型为 Base,动态类型为：SubDerived
					//重要的理解：pb动态类型从原来的Derived,变到现在的SubDerived
					//也说明了程序运行到这里，才可以确定pb的动态类型是什么，并且它是可以变化的

Base* pd = & der; //pd静态类型为 Base* ,动态类型为 Derived;
SubDerived subDer;
pd = &subDer; //pd静态类型为：Base*，动态类型从Derived变成了SubDerived
Base& pe = der; //pd静态类型为Base动态类型为 Derived;
//___________________________________________________________________________
//上面都是动态类型和静态类型不一致的情况，那么什么时候动态类型和静态类型会是一致的呢？
//举几个例子如下情况：
Base* p1 = new Base; //p1静态类型为Base*,动态类型为：Base*，它们是一致的；
Base base1; //base1的静态类型为：Base,base1对象没有动态类型的概念，因为他不是指针或者引用类型
p1 = &base;//p1静态类型为Base*,动态类型为：Base*，它们是一致的；
Base base2; //base2的静态类型为：Base;没有动态类型的概念
p1 = &base2; //p1的静态类型为Base*,动态类型为：Base*，没有发生改变，虽然它们指向的是不同的对象

	return 0;
}

```

下面再介绍静态绑定，动态绑定：

1. 静态绑定：有人也叫为早绑定，早绑定什么呢？对象所调用的函数的地址，这个阶段是程序编译阶段就确定的了；
2. 动态绑定：有人也叫晚绑定，也就是编译阶段时候不能确定对象调用函数的地址，需要程序运行到调用函数的阶段才可以确定；**绑定这个词，它是相对于函数来说的，把对象（包括指针或者引用）和函数绑定在一起**

```cpp
#include<iostream>
using namespace std;

class Base
{
public:
	void fun()
	{
		cout <<" Base::fun() "<< endl;
	}
};
class Derived :public Base
{
public:
	void fun()
	{
		cout <<" Derived::fun() "<< endl;
	}
};
class SubDerived :public Derived
{

public:
	void fun()
	{
		cout << "SubDerived::fun()" << endl;
	}
};
int main()
{
	Base* b1 = new Base;
	b1->fun();
	Derived* d1 = new Derived;
	d1->fun();
	SubDerived* s1 = new SubDerived;
	s1->fun();
	return 0;
}
```

b1 的静态类型为：Base*,动态类型为：Base*; b1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型一致，可是这个动态类型却不影响它的静态绑定的事实；
d1 的静态类型为：Derived*,动态类型为：Derived* ;d1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型一致，可是这个动态类型却不影响它的静态绑定的事实；
s1的静态类型为：SubDerived*,动态类型为：SubDerived*; s1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型一致，可是这个动态类型却不影响它的静态绑定的事实；

![在这里插入图片描述](https://img-blog.csdnimg.cn/9882a188877d41b2b1be446674133335.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZGL5ZaD5ZCW,size_20,color_FFFFFF,t_70,g_se,x_16)

下面我们更改一下，**父类指针指向子类对象**

```cpp
int main()
{
	Base* b1 = new Derived;
	b1->fun(); 
	Derived* d1 = new SubDerived;
	d1->fun();
	return 0;
}

```

**结果也是可以理解的：虽然说是父类指针指向了子类对象，可是也是调用子类对象中父类的成员**，这就是c++中的隐藏，因为父类的成员不是虚函数，所以会出现这样的情况。

b1 的静态类型为：Base*,动态类型为：Derived*; b1->fun( )这个就是**静态绑定**，虽然我们的b1的动态类型和静态类型不一致，可是这个动态类型却不影响它的静态绑定的事实；
d1 的静态类型为：Derived*,动态类型为：SubDerived*; d1->fun( )这个就是**静态绑定**，虽然我们的d1的动态类型和静态类型不一致，可是这个动态类型却不影响它的静态绑定的事实；

**下面我们继续改，此时我们给类加了虚函数：**

```cpp
#include<iostream>
using namespace std;
class Base
{
public:
	void fun()
	{
		cout <<"Base::fun() "<< endl;
	}
	virtual void virFun()
	{
		cout << "Base::virfun() " << endl;
	}
};
class Derived :public Base
{
public:
	void fun()
	{
		cout <<"Derived::fun() "<< endl;
	}
	virtual void virFun()
	{
		cout << "Derived::virfun() " << endl;
	}
};
class SubDerived :public Derived
{

public:
	void fun()
	{
		cout << "SubDerived::fun()" << endl;
	}
	virtual void virFun()
	{
		cout << "SubDerived::virfun() " << endl;
	}
};
void Test3()
{
	Base* b1 = new Derived;
	b1->virFun();
	Base* b2 = new SubDerived;
	b2->virFun();
	Base* b3 = b2;
	b3->virFun();
	Derived* d1 = new SubDerived;
	d1->virFun();
}
int main()
{
	Test3();
	return 0;
}
```

运行结果：

![1690876825165](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1690876825165.png)

**有了虚函数，并且子类重写父类的虚函数，且父类的指针指向子类对象，那么就会发生变化，此时就发生了==多态==的行为：==用父类的指针可以调用子类中的成员了==**。

==总的一句话说：只有虚函数使用的绑定才是动态绑定。==

但不代表说虚函数的绑定都是动态绑定，前提还得是**指针或引用**类型绑定虚函数才可以；

其他的函数绑定方式都是静态绑定！不管你的指针类型引用类型或对象来说是静态类型还是动态类型，只要它们不联系上虚函数都是静态绑定！

下面的例子：

```cpp
int main() {
    Base b;
    b.virFun();
    
    Base* b1 = new Base;
    b1->virFun();
    return 0;
}
```

b对象是普通的对象，不管怎么说肯定都是静态绑定。

对于b1而言，其静态类型为Base*， 动态类型也是 Base *，虽然都是一样的，但是由于他是指针类型的，这个也是**==动态绑定==**！不要理解成静态绑定了。

**建议：**

绝对不要**重新定义继承而来的非虚(non-virtual)函数**（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，**没有多态**，也这将给程序留下不可预知的**隐患和莫名其妙的BUG**。

参考：[(44条消息) 对C++中的静态类型，动态类型，静态绑定，动态绑定的理解_c++静态类型动态类型_呋喃吖的博客-CSDN博客](https://blog.csdn.net/m0_46606290/article/details/121538603)

#### **65. 全局变量和局部变量有什么区别？**

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量分配在**==静态存储区域==**，在程序的各个部分都可以用到；局部变量分配在**==堆栈区==**，只能在局部使用。



#### 66. C/C++程序的5种内存分区

C/C++主要有以下五种内存存储区：

![img](http://oss.interviewguide.cn/img/202205220021689.png)

- **全局/静态存储区域**

存**全局变量，静态变量**。程序编译时内存已分配好，并存在于程序整个运行期间，程序结束后由系统统一释放。

- **栈区**

存放**函数的参数值，局部变量**，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。

- **堆（动态内存分配）**：

通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。

- **字符/文字常量区**

存放**常量字符串**，程序结束时由系统释放。

- **程序代码区**

存放函数体的二进制代码



#### 67. 指针加减计算要注意什么？

指针加减本质是对其所指**地址的移动**，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。

遇到指针的计算，**需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果**。int arr[10];  arr+1就代表指向下一个int型变量，实际跨越了4个字节。



#### 68. 怎样判断两个浮点数是否相等？

由于浮点数存在精度问题，所以对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！对于两个浮点数比较只能通过相减并与**预先设定的精度比较**，记得要取绝对值！

```cpp
const double EPS = 0.0000001;
abs(a - b) < EPS
```



#### 69. 类如何实现只能静态分配和只能动态分配

C++中建立类的对象有两种方式：
（1）静态建立，例如 A a;
静态建立一个类对象，就是由编译器为对象在栈空间中分配内存。使用这种方法，是**直接调用类的构造函数**。
（2）动态建立，例如 A* p = new A();
动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步：第一步执行**operator new( )**函数，在**堆空间**中搜索一块内存并进行分配；第二步调用类的构造函数构造对象。这种方法是**间接调用类的构造函数**。



**只能静态分配：**(只能在栈上分配)

只有使用new运算符，对象才会被建立在堆上。因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有，实现如下：

```cpp
class A  
{  
private:  
     void* operator new(size_t t){}          //注意函数的第一个参数和返回值都是固定的  
     void operator delete(void* ptr){}       //重载了new就需要重载delete  
public:  
     A(){}  
     ~A(){}  
};  
```

**只能动态分配：**（只能在堆上分配）

当我们想**禁止在栈中产生对象**时，如何来实现呢？

将构造函数设为private行吗？no！这样**对象虽然不能在栈中产生，但同样也不能在堆中产生**了。

将析构函数设为private行吗？bad！这样虽然限制了栈对象，但同时也**限制了继承**。

将析构函数设为protected行吗？yes！

把类的构造函数和析构函数设为protected属性。**类对象不能访问，但是派生类可以继承，也可以访问**。



#### 70. 如果想将某个类用作基类，为什么该类必须定义而非声明？

派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。

所以必须定义而非声明。(至少父亲是已经存在的，才可能有孩子)



#### 71.  知道C++中的组合吗？它与继承相比有什么优缺点吗？

**1. 继承**

继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。

继承的缺点有以下几点：

- 父类的内部细节对子类是可见的。
- 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
- 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。

**2. 结合**

组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。

组合的优点：

- 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。

- 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
- 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。

组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义



#### 72. 函数指针

1. **什么是函数指针？**

   如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。

2. **函数指针的声明方法**

   ```cpp
   int (*pf)(const int&, const int&);
   ```

    上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&参数的函数。注意*pf两边的括号是必须的。

3.  **为什么有函数指针**

   函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。

4. **一个函数名就是一个指针，它指向函数的代码**

   一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。

5. **两种方法赋值**

   指针名 = 函数名； 指针名 = &函数名



#### 73. 结构体变量比较是否相等

1. **重载了 “==” 操作符**

```cpp
struct foo {

  int a;
  int b;

  bool operator==(const foo& rhs) *//* *操作运算符重载*

  {
    return( a == rhs.a) && (b == rhs.b);
  }
};
```

2. 元素的话，一个个比；
3. 指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真。



#### 74. 你知道printf函数的实现原理是什么吗？

高地址像低地址生长？低地址向高地址生长？



#### 75. cout和printf有什么区别？

很多人认为cout<<是一个函数，其实不是的，它是类`std::ostream`的全局对象。而printf是一个函数。对于新定义的类，printf想要输入输出一个**==自定义的类的成员是天方夜谭的==**，而iostream中使用的位运算符都是可重载的，并且可以将清空缓冲区的自由交给了用户（在printf中的输出是没有缓冲区的），而且流风格的写法也更加自然和简洁。



#### 76. 你知道重载运算符吗？

运算符重载与函数重载比较类似，相当于让一个运算符具有另外一种含义。运算符重载的本质是函数重载，实现了类的多态性。对于自定义类需要重载运算符重新定义基本运算操作。



#### 77. 输入一个n，找质数

```cpp
int main() {
    int n;
    cout << "请输入n：";
    cin >> n;

    bool flag = true;
    for (int i = 1; i < n; ++i) {
        for (int j = 2; j <= sqrt(i); ++j) {
            if (i % j == 0) {
                flag = false;
                break;
            }
        }
        if (flag) {
            cout << i << " ";
        }
        flag = true;
    }
    system("pause");
    return 0;
}
```



#### 78. 当程序中有函数重载时，函数的匹配原则和顺序是什么？

1. 名字查找
2. 确定候选函数
3. 寻找最佳匹配



#### 79. 定义和声明的区别

**如果是指变量的声明和定义：** 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。

**如果是指函数的声明和定义：** 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。



#### 80. 全局变量和static变量的区别

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。

这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。

**而静态全局变量则限制了其作用域**，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

static全局变量与普通的全局变量的区别是**static全局变量只初始化一次**，防止在其他文件单元被引用。



#### 81. 静态成员与普通成员的区别是什么？

1. 生命周期

静态成员变量从类被加载开始到类被卸载，一直存在；

普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；

1. 共享方式

静态成员变量是全类共享；普通成员变量是每个对象单独享用的；

1. 定义位置

普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；

1. 初始化位置

普通成员变量在类中初始化；静态成员变量在类外初始化；

1. 默认实参

可以使用静态成员变量作为默认实参。



#### 82. 说一下你理解的 ifdef endif代表着什么？

1. 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。

2. 条件编译命令最常见的形式为：

   ```cpp
   #ifdef 标识符  
   程序段1  
   #else  
   程序段2  
   #endif
   ```

   

3. 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。



#### 83. 隐式转换，如何消除隐式转换？

1. C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换。比如数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。
2. 隐式转换也体现了C++面向对象的多态性，比如子类的对象可以使用父类指针接收，这就是多态的体现。
3. C++中提供了**explicit**关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。



#### 84. 如何在不使用额外空间的情况下，交换两个数？你有几种方法

```cpp
1.算数
x = x + y;
y = x - y;
x = x - y;

2.异或（只能对int,char）
首先介绍一下异或的性质：
a ^ a = 0;
a ^ b = b ^ a;
a ^ 0 = a;
(a ^ b) ^ c = a ^ (b ^ c);

此时交换的话就是下面的方法：
x = x ^ y;
y = x ^ y = x ^ (y ^ y) = x ^ 0 = x
x = x ^ y = x ^ y ^ x = x ^ x ^ y = 0 ^ y = y 
```



#### 85. 你知道strcpy和memcpy的区别是什么吗？sprintf

1. 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等；
2. 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出memcpy则是根据其第3个参数决定复制的长度；
3. 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。

用法如下：

```cpp
// 将字符串复制到数组 dest 中
#include <stdio.h>
#include <string.h>
 
int main ()
{
   const char src[50] = "http://www.runoob.com";
   char dest[50];
 
   memcpy(dest, src, strlen(src)+1);
   printf("dest = %s\n", dest);
   
   return(0);
}
```

sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串； sprintf主要实现其他数据类型格式到字符串的转化；  sprintf的效率是三者中最低的。

#### 86. 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？

参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针。char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。



#### 87. 如果有一个空类，它会默认添加哪些函数？

```cpp
1)  Empty(); // 缺省构造函数
2)  Empty( const Empty& ); // 拷贝构造函数
3)  ~Empty(); // 析构函数
4)  Empty& operator=( const Empty& ); // 赋值运算符
```



#### 88. C++中标准库是什么？

1. C++ 标准库可以分为两部分：

   标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。

   面向对象类库： 这个库是类及其相关函数的集合；

2. 输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数；
3. 标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库。



#### 89. 在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？

对比值传递，引用传参的好处：

1. 在函数内部可以对此参数进行修改；
2. 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）

但是有以下的限制：

1. 不提倡返回局部变量的引用。因为函数返回以后局部变量就会被销毁，会出现无法预见的BUG;
2. 不提倡返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露。
3. 可以返回类成员的引用，但是**最好是const**。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。



#### 90. 如何阻止一个类被实例化？有哪些方法？

首先来谈谈，为什么需要阻止一个类被实例化。

不想一个类被实例化通常有两个目的：抽象类和工具类 ，下面分别简单解释下抽象类和工具类的使用场景。

1. **抽象类**

   实现该类的的就是想成为一个抽象类，抽象类一般只被继承，不能被实例化，例如最基本的例子

   - 【动物类】是一个抽象类；
   - 【猴子类】【猫类】【狗类】这三个类继承自【动物类】；
   - 【猴子类】【猫类】【狗类】可以被实例化；
   - 【动物类】不能被实例化；
     这种类更多的是用来定义接口，而完全不关心实现。

2. **工具类**

   这种类提供一些功能但是一般不需要实现成一个实体，感觉上这种类更多的像是发挥了namespace的作用，或者说把一些功能模块化，体现隔离或者解耦思想。例如一个所谓的【计算类】用于计算“加 减 乘 除”四种最简单的计算。只需要提供 add(), sub()，multi()，div()四个方法就可以了，也不需要什么成员变量，也不需要维护什么状态。

两种方法来实现：

1. 为类定义纯虚成员函数；（一般是**声明一个pure virtual析构函数**）
2. 将构造函数声明为protect或者private。（一般是**非public构造函数**+静态方法调用构造函数一般是用于单例输出的场景）



#### 91. 你知道Debug和Release的区别是什么吗？

1. 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；
2. 发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。
3. 实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。



#### 92. static_cast比C语言中的转换强在哪里？

1. 更加安全；
2. 更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图。



#### 93. 成员函数里memset(this,0,sizeof(*this))会发生什么？

1. 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；
2. 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
3. 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。



#### 94. 你知道回调函数吗？它的作用？

1. 当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；
2. 回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1. 声明；2. 定义；3. 设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；
3. 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；
4. 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。



#### 95. 为什么不能把所有的函数写成内联函数?

内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：

- 函数体内的代码比较长，将导致内存消耗代价；
- 函数体内有循环，函数执行时间要比函数调用开销大；



#### 96. 为什么C++没有垃圾回收机制？这点跟Java不太一样

- 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。
- 垃圾回收会使得C++不适合进行很多底层的操作。



#### 97. 什么是内存池，如何实现？

内存池（Memory Pool） 是一种**内存分配**方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。



#### 98. 可以说一下你了解的C++得内存管理吗？

和第66题内存分区是一样的。



#### 99. C++中类的数据成员和成员函数内存分布情况

C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。 类分为成员变量和成员函数，我们先来讨论成员变量。

一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：

```
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        this->age = 23;
    }
    void printAge()
    {
        cout << this->age <<endl;
    }
    ~Person(){}
public:
    int age;
};

int main()
{
    Person p;
    cout << "对象地址："<< &p <<endl;
    cout << "age地址："<< &(p.age) <<endl;
    cout << "对象大小："<< sizeof(p) <<endl;
    cout << "age大小："<< sizeof(p.age) <<endl;
    return 0;
}

//对象地址：0000009A6ACFF694
//age地址：0000009A6ACFF694
//对象大小：4
//age大小：4
```

从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的**函数都是存放在代码区的**，不管是全局函数，还是成员函数。

静态成员函数和非静态成员函数都是存放在**代码区**。（不要被static误导）



#### 100. 关于this指针知道什么？全说出来

- this指针是类的指针，当有一个对象声明时，系统会为这个对象分配一块内存空间，this指针指向这块内存空间，存放的是对象的**数据成员或虚函数表指针**（==**不包括成员函数**==）。
- this指针只能在成员函数中使用，在**全局函数**、静态成员函数中都不能用this。（静态函数不属于某个类）。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

this指针一般在下面两种情况的时候使用：

- 一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
- 另外一种情况是当形参数与成员变量名相同时用于区分，如this->n = n （不能写成n = n）。

**类的this指针有以下特点**

- **this**只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，**传入参数为当前对象地址，成员函数第一个参数为**为**T \* const this**

  ```cpp
  class A{public:	int func(int p){}};
  ```

  其中，**func**的原型在编译器看来应该是：**int func(A \* const this,int p);**

- 由此可见，**this**在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

  ```cpp
  A a;a.func(10);//此处，编译器将会编译成：A::func(&a,10);
  ```



#### 101. 几个this指针的易混问题

this指针只能在一个类的非静态，非全局成员函数中调用，它表示当前对象的地址，下面三种模式是等价的：

```cpp
void Date::setMonth( int mn ) {
    month = mn; // 这三句是等价的
    this->month = mn;
    (*this).month = mn;
}
```

1. **this指针是什么时候创建的?**

   this在成员函数的开始执行前构造的，在成员的执行结束后清除。

2. **this指针存放在何处? 堆,栈,全局变量,还是其他?**

   this指针会因编译器不同，而放置的位置不同。可能是栈，也可能是寄存器，甚至全局变量。

3. **this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？**

   this是通过函数参数的首参数来传递的。这个在之前也提到过了函数参数传递的等价形式，this在第一个参数。

4. **this指针是如何访问类中的变量的？**

   this指针是通过成员函数来访问类中的变量的，具体而言，执行成员函数时，编译器会理解将改成员函数的首参数理解为指向改对象的指针，即this指针，进入函数之后，便可以直接使用this指针访问当前实例对象的变量。

5. **我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？**

   **this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。并且来说，就算在成员函数里面，this本来就是一个指针，如果要获得地址直接 `(long) this` 即可。

   注意，this一般而言是一个**右值**，所以`&this`肯定是不合法的。

6. **每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？**

   普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。



#### 102. 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

首先来说，肯定**可以在成员函数中调用delete this**。

通过代码来看看这个问题：

```cpp
class Test
{
public:
    Test(int _x);
    void foo();
    void show();
    void show(int);
private:
    int x;
};

Test::Test(int _x) :x(_x)
{
}

void Test::show()
{
    cout << "x = " << x << endl;
}

void Test::show(int)
{
    cout << "this is show int" << endl;
}

void Test::foo()
{
    delete this;
}

int main()
{
    Test* t1 = new Test(5);
    cout << "before" << endl;
    t1->show();
    t1->foo();
    cout << "after" << endl;
    t1->show();
    t1->show(1);
    system("pause");
    return 0;
}
```

运行结果如下所示：

![1691399224765](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1691399224765.png)

可以看到，在foo函数中delete了this，确实起到了作用（因为x的内存已经被释放了，x已经随便给了一个值），但是`show(int)`函数还是可以执行。

这说明了：并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法**不涉及这个对象的数据成员和虚函数**。

可以按照下面的解释：

在类对象的内存空间中，只有**数据成员和虚函数表指针**，并不包含代码内容（代码区），而普通的成员函数，包括全局函数和静态函数，都是存放在代码区的。所以使用delete释放了类对象的内存空间，只释放了数据成员和虚函数表指针的内存，对于代码区中的函数而言，不涉及到this指针的内容，所以是不受影响的，仍然可以调用。

追问：**delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？**

delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，**可能是缓冲或者其他什么原因**，导致这段内存空间暂时并没有被系统收回，此时这段内存是可以访问的。



#### 103. 在析构函数中调用delete this会怎么样？

```cpp
#include <iostream>
using namespace std;
 
class A
{
public:
	A()
	{
		cout<<"A()"<<endl;
	}
	~A()
	{
		cout<<"~A()"<<endl;
		delete this;
	}
};
 
int main()
{
	A a;
	return 0;
}
```

析构函数中调用delete this：上面这段程序的`delete this`会先调~ A()，然后再释放空间，这样每次调用delete都会调用~A()，而 ~A()又要调用delete，他们相互调用，就会形成死循环，造成堆栈溢出。



#### 104. 你知道空类的大小是多少吗？

1. ==C++空类的大小不为0，不同编译器设置不一样，vs设置为1，**因为空类可以实例化，可以实例化很多个对象，在内存地址上就不能区分该类实例化出的实例，所以编译器会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址**。==
2. C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；
3. 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
4. C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。



#### 105. 指针占几个字节？

32位系统占4个字节；64位系统占8个字节。



#### 106. C++类的大小怎么决定？

先总述：

1. 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
2. 内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
3. 虚函数的话，会在类对象插入vptr指针，加上指针大小；
4. 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。

- **类的大小与什么有关系？**

  与类大小**==有关==**的因素：普通成员变量（非静态和全局成员变量），虚函数，继承（单一继承，多重继承，重复继承，虚拟继承）包括**s**。

  与类大小**==无关==**的因素：静态成员变量，静态成员函数及普通成员函数。

- **空类**

  空类的大小编译器优化为1，但是如果某一个类继承空类，那么那个空类的大小就会被优化。

  ```cpp
  class A {
  
  };
  
  class B : public A {
  public:
  	int m_a;
  };
  
  int main()
  {
  	A a;
  	cout << sizeof(a) << endl;
  
  	B b;
  	cout << sizeof(b) << endl;
  
  	system("pause");
  	return 0;
  }
  
  // 1
  // 4
  ```

- **内存对齐问题**

- **含虚函数的单一继承**

  ```cpp
  class Base
  {
  private:
      char a;
  public:
      virtual void f();
      virtual void g();
  };
  class Derived:public Base
  {
  private:
      int b;
  public:
      void f();
  };
  class Derived1:public Base
  {
  private:
      double b;
  public:
      void g();
      virtual void h();
  };
  ```

  基类Base中含有一个char型成员变量，以及两个虚函数，此时Base类的内存布局如下：

  ![img](https://img-blog.csdn.net/20180503185905354)

  内存布局的最一开始是vfptr（virtual function ptr）即虚函数表指针（只要含虚函数，一定有虚函数表指针，而且该指针一定位于类内存模型最前端），接下来是Base类的成员变量，按照在类里的声明顺序排列，当然啦，还是要像上面一样注意内存对齐原则！

  继承类Derived继承了基类，重写了Base中的虚函数f()，还添加了自己的成员变量，即int型的b，这时，Derived的类内存模型如下：

  ![img](https://img-blog.csdn.net/20180503190906435)

  此种情况下，最一开始的还是虚函数表指针，只不过，在Derived类中被重写的虚函数f()在对应的虚函数表项的Base::f()已经被替换为Derived::f()，接下来是基类的成员变量char a，紧接着是继承类的成员变量int b，按照其基类变量声明顺序与继承类变量声明顺序进行排列，并注意内存对齐问题。

  继承类Derived1继承了基类，重写了Base中的虚函数g()，还添加了自己的成员变量（即double型的b）与自己的虚函数（virtual h() ），这时，Derived1的类内存模型如下：

  ![img](https://img-blog.csdn.net/20180503211646994)

  此种情况下，Derived1类一开始仍然是虚函数表指针，只是在Derived1类中被重写的虚函数g()在对应的虚函数表项的Base::g()已经被替换为Derived1::g()，新添加的虚函数virtual h()位于虚函数表项的后面，紧跟着基类中最后声明的虚函数表项后，接下来仍然是基类的成员变量，紧接着是继承类的成员变量。

- **含虚函数的多重继承**

  ```cpp
  class Base1
  {
  private:
      char a;
  public:
      virtual void f();
      virtual void g1();
  };
  class Base2
  {
  private:
      int b;
  public:
      virtual void f();
      virtual void g2();
  };
  class Base3
  {
  private:
      double c;
  public:
      virtual void f();
      virtual void g3();
  };
  class Derived:public Base1, public Base2, public Base3
  {
  private:
      double d;
  public:
      void f();
      virtual void derived_func();
  }
  ```

  首先继承类多重继承了三个基类，此外继承类重写了三个基类中都有的虚函数virtual f()，还添加了自己特有的虚函数derived_func()，那么，新的继承类内存布局究竟是什么样子的呢？请看下图！先来看3个基类的内存布局：

  ![img](https://img-blog.csdn.net/20180503213023625)

  

  紧接着是继承类Derived的内存布局：

  ![img](https://img-blog.csdn.net/20180503214050458)

  首先，Derived类自己的虚函数表指针与其声明继承顺序的第一个基类Base1的虚函数表指针合并，此外，若Derived类重写了基类中同名的虚函数，则在三个虚函数表的对应项都应该予以修改，Derived中新添加的虚函数位于第一个虚函数表项后面，Derived中新添加的成员变量位于类的最后面，按其声明顺序与内存对齐原则进行排列。

- **菱形继承的问题及解决方案：虚拟继承**

  （1）不同环境下虚拟继承对类大小的影响

  在vs环境下，采用虚拟继承的继承类会有自己的虚函数表指针（**==假如基类有虚函数，并且继承类添加了自己新的虚函数==**）

  在gcc环境下及mac下使用clion，采用虚拟继承的继承类没有自己的虚函数表指针（假如基类有虚函数，无论添加自己新的虚函数与否），而是共用父类的虚函数表指针

  （2）虚拟继承会给继承类添加一个虚基类指针（virtual base ptr 简称vbptr），其位于类虚函数指针后面，成员变量前面，若基类没有虚函数，则vbptr其位于继承类的最前端。

  **虚继承的定义，为什么需要虚拟继承？**

  虚极继承主要是为了解决**菱形继承下公共基类的多份拷贝问题：**会造成同名成员的歧义

  ![img](https://pic3.zhimg.com/80/v2-37a3fde641d2e10e659d01f8041eb1b6_720w.webp)

  ```cpp
  //间接基类A
  class A{
  protected:
      int m_a;
  };
  
  //直接基类B
  class B: public A{
  protected:
      int m_b;
  };
  
  //直接基类C
  class C: public A{
  protected:
      int m_c;
  };
  
  //派生类D
  class D: public B, public C{
  public:
      void seta(int a){ m_a = a; }  //命名冲突
      void setb(int b){ m_b = b; }  //正确
      void setc(int c){ m_c = c; }  //正确
      void setd(int d){ m_d = d; }  //正确
  private:
      int m_d;
  };
  
  int main(){
      D d;
      return 0;
  }
  ```

  这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。

  为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：

  ```cpp
  void seta(int a){ B::m_a = a; }
  ```

  这样表示使用 B 类的 m_a。当然也可以使用 C 类的：

  ```cpp
  void seta(int a){ C::m_a = a; }
  ```

  如果将上述例子改为虚继承：

  ```cpp
  class B: virtual public A
  class C: virtual public A
  ```

  就可以设置m_a了，此时A就是B和C的虚基类。虽然感觉像是共享关系，但是还是各论各的，D中的m_a改了，A，B，C中的都不会改。

参考文章：[C++类大小详尽讲解_c++类的大小继承_月赋情长的博客-CSDN博客（）](https://blog.csdn.net/longjialin93528/article/details/80160467)

还需要补充一点，后面再说。



#### 107. c++常见的锁？

这个之后再总结

#### ==108. 构造函数和析构函数调用虚函数？==

一般来说尽量避免这样的操作。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生。

- 从语法上讲，调用完全没有问题。

- 但是从效果上看，往往不能达到需要的目的。

  

#### 109. gdb调试段错误

#### 110. C++的多态如何实现

C++的多态性，**一言以蔽之**就是：在基类的函数前加上**virtual**关键字，在派生类中重写该函数，使用父类的指针指向子类的对象，此时使用该指针调用被virtual修饰的函数，就会根据动态绑定的类型，也就是说实际的对象的类型，然后调用相应的函数。

举例说明，如果A是父类，B是子类，使用`A *a = new B();` 此时该指针的静态绑定是A类型，动态绑定是B类型，根据动态绑定的类型，最终调用同名函数的时候，会调用B中的函数。这就是C++多态的体现。

如果不加virtual关键字的话，这就是隐藏，按照上面的流程，最终执行的是父类A的相关函数，B中的函数就似乎被隐藏了。使用指针或者引用都会存在这样的问题。



#### 111. 为什么析构函数一般写成虚函数

还是之前提到的静态绑定和动态绑定的问题和多条的问题。面试如果问这个问题直接将多态和这个问题一起回答。

由于类的多态，**基类指针可以指向派生类的对象**，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，**而派生类的析构函数又自动调用基类的析构函数**，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施**静态绑定**，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。



#### 112. 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？

析构函数：

- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
- 由于类的多态，**基类指针可以指向派生类的对象**，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，**而派生类的析构函数又自动调用基类的析构函数**，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施**静态绑定**，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。
- **析构函数可以是纯虚函数**，含有纯虚函数的类是**抽象类**，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

对于构造函数而言：

- 虚函数对应一个vtable（虚函数表），类中存储一个vptr（虚函数表指针）指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。（首先是不能）
- 其次就是没有必要。虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数。



#### 113. 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间？

虚函数表中存放的是虚函数的地址，由于在编译时期就可以确定虚函数表的大小，也就是虚函数的个数，不必动态分配内存空间存储虚函数表，所以不在堆中。这一点类似于静态变量或者全局变量，所以虚函数表存放在静态区，也可以说是全局区。

虚函数表指针一般在对该类进行实例化时，在构造函数执行时会对虚函数表指针进行初始化，并且存在对象内存内存布局的最前面。所以构造函数不能是虚函数，这里也可以佐证。



#### 114. 模板是怎么实现的？模板特例化是什么？

1. 编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：**在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。**
2. 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。



#### 115. 构造函数、析构函数、虚函数可否声明为内联函数

在 C++ 中，构造函数、析构函数和虚函数都可以被声明为内联函数。

1. 构造函数（Constructor）：构造函数用于初始化对象，在对象创建时自动调用。在一些简单的情况下，构造函数的代码可能很短，因此可以将构造函数声明为内联函数，以提高执行效率。

2. 析构函数（Destructor）：析构函数用于释放对象占用的资源，并在对象销毁时自动调用。同样地，如果析构函数的代码很简单，也可以将其声明为内联函数。

   在我们看来，这样的写法似乎就是标准的内联函数了，但是编译器不一定这么认为，因为析构和构造海牵涉到内存的申请和释放的问题，本身就不是一个简短的函数。

3. **将虚函数声明为inline，要分情况讨论**

   有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

   上述观点看似正确，其实不然，**如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联**，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开

   **综上**，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。



#### 116. 构造函数、析构函数的执行顺序？

**构造函数的执行顺序：**

1. 基类的构造函数
2. 成员类的构造函数
3. 派生类的构造函数

注意：如果有多个基类，则按照继承的顺序进行调用；如果有多个成员类，则按照成员类在当前类中声明的顺序

**构造函数的执行顺序：**与构造函数的执行顺序完全相反。

1. 派生类的析构函数
2. 成员类的析构函数
3. 基类的析构函数



#### 117. 类什么时候会析构？

1. 对象生命周期结束，被销毁时；
2. delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
3. 对象B是A的成员，A的析构函数被调用时，对象B的析构函数也会被调用；
4. B是A的派生类，B的对象的析构函数被调用时，A的析构函数也会被调用。



#### 118. 构造函数、拷贝构造函数和赋值运算符的区别？

**构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

**拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

**赋值运算符**

对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的

构造函数和拷贝构造函数都是函数，赋值运算符是运算符重载；形参为类对象的时候，调用的是拷贝构造函数；并不是所有的"="都是赋值运算符，比如：

```cpp
Student s;
Student s1 = s;    // 调用拷贝构造函数
Student s2;
s2 = s;    		   // 赋值运算符操作
```

举个例子：

```cpp
class A
{
public:
	A()
	{
		cout << "我是构造函数" << endl;
	}
	A(const A& a)
	{
		cout << "我是拷贝构造函数" << endl;
	}
	A& operator = (A& a)
	{
		cout << "我是赋值操作符" << endl;
		return *this;
	}
	~A() {};
};

int main()
{
	A a1; //调用构造函数
	A a2 = a1; //调用拷贝构造函数
	a2 = a1; //调用赋值操作符
	return 0;
}
```



#### 119. 了解RAIl吗?介绍一下？

RALL核心的设计理念是资源和对象的生命周期绑定，**对象创建获取资源，对象销毁释放资源**，在 RAII 的指导下，C++ 把**底层的资源管理问题**提升到了**对象生命周期管理**的更高层次。

举个例子：最常见的内存泄露的情况就是，使用new在堆区申请一块内存，但是最后忘记了delete，就会造成内存泄露。我们可以将这个指针和对象绑定。

```cpp
#include <iostream>
#include <memory>
 
template<typename T>
class auto_release_ptr
{
public:
	auto_release_ptr(T *t) :_t(t){};
	~auto_release_ptr()
	{
		delete _t;
	};
 
	T * getPtr()
	{
		return _t;
	}
 
private:
	T *_t;
};
 
int main()
{
	for (int i = 1; i <= 10000000; i++)
	{
		auto arp = auto_release_ptr<int32_t>(new int32_t[3]);
		int32_t *ptr = arp.getPtr();
		ptr[0] = 1;
		ptr[1] = 2;
		ptr[2] = 3;
	}
	system("pause");
	return 0;
}
```

c++11新特性中的**智能指针**，**lock_guard**都利用了RALL机制来实现。

